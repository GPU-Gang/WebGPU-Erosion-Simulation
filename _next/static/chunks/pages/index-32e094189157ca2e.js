(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[405],{8312:function(e,r,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return t(559)}])},559:function(e,r,t){"use strict";let n,i,a,o;t.r(r),t.d(r,{default:function(){return pages}});var s=t(6416),u=t(5893),f=t(9008),l=t.n(f),c=t(7294),d=t(4131),h=t.n(d);let SampleLayout=e=>{let r=(0,c.useRef)(null),n=(0,c.useRef)(null),i=(0,c.useMemo)(()=>{if(e.gui){let e=t(4376);return new e.GUI({autoPlace:!1})}},[]),a=(0,c.useRef)(null),o=(0,c.useMemo)(()=>{if(e.stats){let e=t(2792);return new e}},[]),[s,f]=(0,c.useState)(null);return(0,c.useEffect)(()=>{if(i&&n.current)for(n.current.appendChild(i.domElement);i.__controllers.length>0;)i.__controllers[0].remove();o&&a.current&&(o.dom.style.position="absolute",o.showPanel(1),a.current.appendChild(o.dom));let t={active:!0};try{let n=r.current;if(!n)throw Error("The canvas is not available");let a=e.init({canvas:n,pageState:t,gui:i,stats:o});a instanceof Promise&&a.catch(e=>{console.error(e),f(e)})}catch(e){console.error(e),f(e)}return()=>{t.active=!1}},[]),(0,u.jsxs)("main",{children:[(0,u.jsxs)(l(),{children:[(0,u.jsx)("title",{children:"Terrain X"}),(0,u.jsx)("meta",{name:"description",content:e.description}),(0,u.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,u.jsxs)("div",{children:[(0,u.jsx)("h1",{children:e.name}),(0,u.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://github.com/".concat("GPU-Gang/WebGPU-Erosion-Simulation","/tree/main/").concat(e.filename),children:"See it on Github!"}),(0,u.jsx)("p",{children:e.description}),s?(0,u.jsxs)(u.Fragment,{children:[(0,u.jsx)("p",{children:"Something went wrong. Do your browser and device support WebGPU?"}),(0,u.jsx)("p",{children:"".concat(s)})]}):null]}),(0,u.jsxs)("div",{className:h().canvasContainer,children:[(0,u.jsx)("div",{style:{position:"absolute",left:10},ref:a}),(0,u.jsx)("div",{style:{position:"absolute",right:10},ref:n,children:(0,u.jsx)("input",{id:"img-path",type:"file"})}),(0,u.jsx)("canvas",{ref:r})]})]})},makeSample=e=>(0,u.jsx)(SampleLayout,{...e});var p=t(4478),m=class{setResolution(e){this.resolution=e,this.aspectRatio=e[0]/e[1]}updateProjectionMatrix(){s._E.perspective(this.fovy,this.aspectRatio,this.near,this.far,this.projectionMatrix)}update(){this.controls.tick();let e=this.viewMatrix();this.right[0]=-e[0],this.right[1]=-e[4],this.right[2]=-e[8],this.up[0]=e[1],this.up[1]=e[5],this.up[2]=e[9],this.forward[0]=-e[2],this.forward[1]=-e[6],this.forward[2]=-e[10]}viewMatrix(){return this.controls.matrix}getPosition(){return this.controls.eye}constructor(e,r){this.projectionMatrix=s._E.create(),this.fovy=45,this.aspectRatio=1,this.near=.1,this.far=1e6,this.resolution=s.K4.create(400,400),this.right=s.R3.create(1,0,0),this.up=s.R3.create(0,1,0),this.forward=s.R3.create(0,0,1),this.controls=p(document.getElementById("canvas"),{eye:e,center:r,translateSpeed:-1,mode:"orbit"}),this.controls.flipX=!0,this.controls.flipY=!0,this.controls.rotate(0,3.14159,0)}},g=class{create(e){this.device=e}createIndexBuffer(){return this.idxBound||(this.idxBound=!0,this.indexBuffer=this.device.createBuffer({size:this.indices.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),new Uint32Array(this.indexBuffer.getMappedRange()).set(this.indices),this.indexBuffer.unmap()),this.indexBuffer}createPosBuffer(){return this.posBound||(this.posBound=!0,this.posBuffer=this.device.createBuffer({size:this.positions.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.posBuffer.getMappedRange()).set(this.positions),this.posBuffer.unmap()),this.posBuffer}createNormalBuffer(){return this.norBound||(this.norBound=!0,this.normalBuffer=this.device.createBuffer({size:this.normals.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.normalBuffer.getMappedRange()).set(this.normals),this.normalBuffer.unmap()),this.normalBuffer}createUVBuffer(){return this.uvBound||(this.uvBound=!0,this.uvBuffer=this.device.createBuffer({size:this.uvs.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.uvBuffer.getMappedRange()).set(this.uvs),this.uvBuffer.unmap()),this.uvBuffer}elemCount(){return this.count}constructor(){this.count=0,this.idxBound=!1,this.posBound=!1,this.norBound=!1,this.uvBound=!1}};function degToRad(e){return .0174533*e}var v=class extends g{create(e){super.create(e),this.indices=new Uint32Array([0,1,2,0,2,3]),this.normals=new Float32Array([0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0]),this.positions=new Float32Array([-1,-1,0,1,1,-1,0,1,1,1,0,1,-1,1,0,1]),this.uvs=new Float32Array([0,1,1,1,1,0,0,0]),this.count=this.indices.length,this.createIndexBuffer(),this.createPosBuffer(),this.createNormalBuffer(),this.createUVBuffer()}createBindGroup(e,r,t,n,i){return this.bindGroupCreated||(this.bindGroupCreated=!0,this.bindGroup=this.device.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r,offset:t}},{binding:1,resource:n},{binding:2,resource:i.createView()}]})),this.bindGroup}getModelMatrix(){let e=s._E.identity();return s._E.rotateX(e,this.rotation[0],e),s._E.rotateY(e,this.rotation[1],e),s._E.rotateZ(e,this.rotation[2],e),s._E.scale(e,this.scale,e),s._E.translate(e,this.center,e),e}constructor(e=s.vh.create(0,0,0,0),r=s.R3.create(1,1,1),t=s.R3.create(0,0,0)){super(),this.bindGroupCreated=!1,this.center=s.vh.fromValues(e[0],e[1],e[2],1),this.scale=r,this.rotation=t,this.rotation[0]=degToRad(this.rotation[0]),this.rotation[1]=degToRad(this.rotation[1]),this.rotation[2]=degToRad(this.rotation[2])}},x=class extends v{createTerrainBindGroup(e,r,t,n,i,a){return this.bindGroupCreated||(this.bindGroupCreated=!0,this.bindGroup=this.device.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:r,offset:t}},{binding:1,resource:n},{binding:2,resource:i.createView()},{binding:3,resource:{buffer:a,offset:0}}]})),this.bindGroup}},b=class{constructor(){this.nx=256,this.ny=256,this.lowerVertX=-5,this.lowerVertY=-5,this.upperVertX=5,this.upperVertY=5,this.cellDiagX=1176.47,this.cellDiagY=1176.47}};let B=(()=>{let e,r;let t={};return function(n,i){r||(r=n.createShaderModule({label:"textured quad shaders for mip level generation",code:"struct VertexOutput {\r\n    @builtin(position) position : vec4f,\r\n    @location(0) texCoord : vec2f,\r\n}\r\n\r\n@vertex\r\nfn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\r\n    var pos = array<vec2f, 4>(\r\n        vec2f(-1, 1), vec2f(1, 1),\r\n        vec2f(-1, -1), vec2f(1, -1)\r\n    );\r\n    var output : VertexOutput;\r\n    output.texCoord = pos[vertexIndex] * vec2f(0.5, -0.5) + vec2f(0.5);\r\n    output.position = vec4f(pos[vertexIndex], 0, 1);\r\n    return output;\r\n}\r\n\r\n@group(0) @binding(0) var imgSampler : sampler;\r\n@group(0) @binding(1) var img : texture_2d<f32>;\r\n\r\n@fragment\r\nfn fragmentMain(@location(0) texCoord : vec2f) -> @location(0) vec4f {\r\n    return textureSample(img, imgSampler, texCoord);\r\n}"}),e=n.createSampler({minFilter:"linear"})),t[i.format]||(t[i.format]=n.createRenderPipeline({label:"mip level generator pipeline",layout:"auto",vertex:{module:r,entryPoint:"vertexMain"},fragment:{module:r,entryPoint:"fragmentMain",targets:[{format:i.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}}));let a=t[i.format],o=n.createCommandEncoder({label:"mip gen encoder"}),s=i.width,u=i.height,f=0;for(;s>1||u>1;){s=Math.max(1,s/2|0),u=Math.max(1,u/2|0);let r=n.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:e},{binding:1,resource:i.createView({baseMipLevel:f,mipLevelCount:1})}]});++f;let t={label:"mip gen canvas renderPass",colorAttachments:[{view:i.createView({baseMipLevel:f,mipLevelCount:1}),loadOp:"clear",storeOp:"store"}]},l=o.beginRenderPass(t);l.setPipeline(a),l.setBindGroup(0,r),l.draw(4),l.end()}let l=o.finish();n.queue.submit([l])}})(),numMipLevels=function(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];let n=Math.max(...r);return 1+Math.log2(n)|0};async function loadImageBitmap(e){let r=await fetch(e),t=await r.blob();return await createImageBitmap(t,{colorSpaceConversion:"none"})}async function createTextureFromImageWithMip(e,r,t){let n=await loadImageBitmap(r);return function(e,r,t,n){let i=e.createTexture({label:r,format:"rgba8unorm",mipLevelCount:n.mips?numMipLevels(t.width,t.height):1,size:[t.width,t.height],usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return console.log("mip count: "+i.mipLevelCount),!function(e,r,t,n){let{flipY:i}=n;e.queue.copyExternalImageToTexture({source:t,flipY:i},{texture:r},{width:t.width,height:t.height}),r.mipLevelCount>1&&B(e,r)}(e,i,t,!!n.flipY&&n.flipY),i}(e,r,n,t)}let w="assets/uplifts/",y=["hf1_256x256","hf2_256x256","hf1_1201x1201","hf2_1201x1201","hf_2250x2250","hf_4500x4500"],P=["alpes_noise_256x256","alpes_noise_512x512","alpes_noise_1201x1201","alpes_noise_2250x2250","lambda_256x256","lambda_4500x4500"],R=["pattern1_bg","pattern2_bg","pattern3_bg"],S=["Normal","Lambertian"],_=[],T=[],U=[],C=[],I=[],M=[],V=0,G=!1,A=0,D=0,E=s.K4.fromValues(-1,-1),L=!1,F=null,Y=!0;function createRenderPipeline(e,r,t){let n=e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:r}),entryPoint:"vert_main",buffers:[{arrayStride:16,attributes:[{shaderLocation:0,format:"float32x4",offset:0}]},{arrayStride:16,attributes:[{shaderLocation:1,format:"float32x4",offset:0}]},{arrayStride:8,attributes:[{shaderLocation:2,format:"float32x2",offset:0}]}]},fragment:{module:e.createShaderModule({code:r}),entryPoint:"frag_main",targets:[{format:t}]},primitive:{topology:"triangle-list",cullMode:"back"}});return n}function writeMVPUniformBuffer(e,r,t,n,i){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=s._E.identity();var u=i.viewMatrix();a?s._E.multiply(o,n,o):(s._E.multiply(u,n,o),s._E.multiply(i.projectionMatrix,o,o)),e.queue.writeBuffer(r,t,new Float32Array([o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],o[8],o[9],o[10],o[11],o[12],o[13],o[14],o[15],i.right[0],i.right[1],i.right[2],0,i.up[0],i.up[1],i.up[2],0,i.forward[0],i.forward[1],i.forward[2],0,i.getPosition()[0],i.getPosition()[1],i.getPosition()[2],0,i.resolution[0],i.resolution[1],0,0]))}function writeTerrainUniformBuffer(e,r,t,n){e.queue.writeBuffer(r,0,new Float32Array([C[V].width,C[V].height,t.lowerVertX,t.lowerVertY,t.upperVertX,t.upperVertY,n]))}function createTextureOfSize(e,r,t,n,i){return e.createTexture({label:i,size:[r,t,1],format:n?"r8unorm":"rgba8unorm",mipLevelCount:1,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|(!n&&GPUTextureUsage.STORAGE_BINDING)|(!n&&GPUTextureUsage.COPY_SRC)})}let createTextureFromImage=(e,r,t,n,i)=>{let a=createTextureOfSize(e,r.width,r.height,t,i);return n&&e.queue.copyExternalImageToTexture({source:r},{texture:a},[r.width,r.height]),a},init=async e=>{let r,t,u,f,{canvas:l,pageState:c,gui:d,stats:h}=e;d.width=280;let p={heightfield:y[0],uplift:P[0],shadingMode:S[0],eraseTerrain:!1,useCustomBrush:!1,customBrush:R[0],brushScale:2,brushStrength:5,streamPower:500,heightFieldPath:"Not in use",onClickFunc:function(){var e=document.getElementById("img-path");e.addEventListener("change",async function(){var r=e.files[0];if(e.files.length){let n=URL.createObjectURL(r),i=await fetch(n);for(var t in F=await createImageBitmap(await i.blob()),L=!0,g=0,p.heightFieldPath=r.name,d.__controllers)d.__controllers[t].updateDisplay();e.value=""}}),e.click()},useRenderBundles:!1},g=0;d.add(p,"heightfield",y).onFinishChange(()=>{g=0,L=!1}),d.add(p,"uplift",P).onFinishChange(()=>{g=1}),d.add(p,"shadingMode",S),d.add(p,"eraseTerrain"),d.add(p,"useCustomBrush"),d.add(p,"customBrush",R).onFinishChange(()=>{n=U[R.indexOf(p.customBrush)],g=2}),d.add(p,"brushScale",0,10,1),d.add(p,"brushStrength",0,20),d.add(p,"streamPower",500,2e3,250),d.add(p,"heightFieldPath").name("Custom Height Map"),d.add(p,"onClickFunc").name("Upload Custom Height Map"),d.add(p,"useRenderBundles").name("Use Render Bundles");let B=await navigator.gpu.requestAdapter(),X=await B.requestDevice();if(!c.active)return;let O=l.getContext("webgpu"),N=window.devicePixelRatio;l.width=l.clientWidth*N,l.height=l.clientHeight*N;let H=navigator.gpu.getPreferredCanvasFormat();l.addEventListener("mousedown",e=>{e.ctrlKey&&(e.stopImmediatePropagation(),G=!0,A=e.offsetX,D=e.offsetY)},!0),l.addEventListener("mousemove",e=>{e.ctrlKey&&(e.stopImmediatePropagation(),0==e.button&&(A=e.offsetX,D=e.offsetY))},!0),l.addEventListener("mouseup",()=>{G=!1}),O.configure({device:X,format:H,alphaMode:"premultiplied"}),(a=new v(s.vh.create(2.5,2.5,0,0),s.R3.create(.3,.3,1))).create(X),(o=new x(s.vh.create(0,0,0,0),s.R3.create(1,1,1))).create(X),h.showPanel(0);let q=s.R3.create(o.center[0],o.center[1]+2,o.center[2]),j=new m(s.R3.create(0,0,-10),q);j.setResolution(s.K4.create(l.width,l.height)),j.updateProjectionMatrix();let z=createRenderPipeline(X,"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n}\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n\n@group(0) @binding(1) var mySampler : sampler;\n@group(0) @binding(2) var myTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fs_UV : vec2<f32>,\n}\n\n@vertex\nfn vert_main(\n  @location(0) vs_pos: vec4<f32>,\n  @location(1) vs_nor: vec4<f32>,\n  @location(2) vs_uv: vec2<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = uniforms.modelViewProjectionMatrix * vs_pos;\n  output.fs_UV = vs_uv;\n  return output;\n}\n\n@fragment\nfn frag_main(@location(0) fs_UV : vec2<f32>) -> @location(0) vec4<f32> {\n  return textureSample(myTexture, mySampler, fs_UV);\n}",H),k=createRenderPipeline(X,"struct Uniforms {\r\n  modelViewProjectionMatrix : mat4x4<f32>,\r\n  right: vec3<f32>,\r\n  up: vec3<f32>,\r\n  forward: vec3<f32>,\r\n  eye: vec3<f32>,\r\n  screenDims: vec2<f32>,\r\n}\r\n\r\nstruct Terrain\r\n{\r\n    textureSize: vec2<i32>, // texture size\r\n    lowerLeft: vec2<f32>,   // AABB\r\n    upperRight: vec2<f32>,  // AABB\r\n    shadingMode: f32,\r\n}\r\n\r\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\r\n@group(0) @binding(1) var heightFieldSampler : sampler;\r\n@group(0) @binding(2) var heightfield : texture_2d<f32>;\r\n@group(0) @binding(3) var<uniform> terrain : Terrain;\r\n\r\nstruct VertexOutput {\r\n  @builtin(position) Position : vec4<f32>,\r\n  @location(0) fs_UV : vec2<f32>,\r\n}\r\n\r\n@vertex\r\nfn vert_main(\r\n  @location(0) vs_pos: vec4<f32>,\r\n  @location(1) vs_nor: vec4<f32>,\r\n  @location(2) vs_uv: vec2<f32>) -> VertexOutput {\r\n  var output : VertexOutput;\r\n  output.Position = uniforms.modelViewProjectionMatrix * vs_pos;\r\n  output.fs_UV = vs_uv;\r\n  return output;\r\n}\r\n\r\n// ----------- FRAG SHADER ------------ //\r\n\r\nconst PI : f32 = 3.14159265358979323;\r\nconst FOVY : f32 = 45.0f * PI / 180.0;\r\nconst MAX_ITERS : i32 = 256;\r\nconst MIN_DIST : f32 = 0.01f;\r\nconst MAX_DIST : f32 = 1000000.0f;\r\nconst EPSILON : f32 = MIN_DIST;\r\nconst heightRange : vec2<f32> = vec2(0, 1);       // hardcoded range for now\r\nconst K: f32 = 1.0f;                              // hardcoded Lipschitz constant\r\nconst lightPos: vec3<f32> = vec3(5, 12, -5);       // light position\r\n\r\n// Data structures\r\nstruct Ray {\r\n    origin: vec3<f32>,\r\n    direction: vec3<f32>,\r\n};\r\n\r\nstruct IntersectAABBResult\r\n{\r\n    hit: bool,\r\n    tNear: f32,\r\n    tFar: f32\r\n}\r\n\r\nstruct RaymarchResult\r\n{\r\n    hit: bool,\r\n    t: f32,\r\n    hitPoint: vec3<f32>,\r\n}\r\n\r\n/* =================================\r\n * ========= RAY FUNCTIONS =========\r\n * =================================\r\n*/\r\n\r\nfn rayCast(fs_UV: vec2<f32>) -> Ray\r\n{\r\n    var ndc : vec2<f32> = (fs_UV);\r\n    ndc = ndc * 2.f - vec2(1.f);\r\n\r\n    let aspect : f32 = uniforms.screenDims.x / uniforms.screenDims.y;\r\n    let reference : vec3<f32> = uniforms.eye + uniforms.forward;\r\n    let V : vec3<f32> = uniforms.up * tan(FOVY * 0.5);\r\n    let H : vec3<f32> = uniforms.right * tan(FOVY * 0.5) * aspect;\r\n    let p : vec3<f32> = reference + H * ndc.x + V * ndc.y;\r\n\r\n    return Ray(uniforms.eye, normalize(p - uniforms.eye));\r\n}\r\n\r\nfn intersectAABB(ray: Ray) -> IntersectAABBResult\r\n{\r\n    var result : IntersectAABBResult;\r\n    result.hit = false;\r\n    result.tNear = -1;\r\n    result.tFar = -1;\r\n\r\n	var rinvDir : vec3<f32> = 1.0 / ray.direction;\r\n	var delta : f32 = 0.1 * (heightRange.y - heightRange.x);\r\n	var tbot : vec3<f32> = rinvDir * (vec3(terrain.lowerLeft.x, heightRange.x - delta, terrain.lowerLeft.y) - ray.origin);\r\n	var ttop : vec3<f32> = rinvDir * (vec3(terrain.upperRight.x, heightRange.y + delta, terrain.upperRight.y) - ray.origin);\r\n\r\n	var tmin : vec3<f32> = min(ttop, tbot);\r\n	var tmax : vec3<f32> = max(ttop, tbot);\r\n	var t : vec2<f32> = max(tmin.xx, tmin.yz);\r\n	var t0 : f32 = max(t.x, t.y);\r\n	t = min(tmax.xx, tmax.yz);\r\n	var t1 : f32 = min(t.x, t.y);\r\n\r\n    result.hit = t1 > max(t0, 0.0);\r\n    result.tNear = t0;\r\n    result.tFar = t1;\r\n\r\n    return result;\r\n}\r\n\r\n/* ===============================\r\n * ======== SDF Primitives =======\r\n * ===============================\r\n*/\r\n\r\nfn sdfSphere(p: vec3<f32>) -> f32\r\n{\r\n    return distance(p, vec3(0,0,0)) - 0.257f;\r\n}\r\n\r\nfn sdfBox2D(p: vec2<f32>, lowerLeft: vec2<f32>, upperRight: vec2<f32>) -> f32\r\n{\r\n	var center: vec2<f32> = 0.5 * (lowerLeft + upperRight);\r\n	var r: vec2<f32> = 0.5 * (upperRight - lowerLeft);\r\n	var q: vec2<f32> = abs(p - center) - r;\r\n    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0);\r\n}\r\n\r\nfn sdfBox3D(p: vec3<f32>, lowerLeft: vec3<f32>, upperRight: vec3<f32>) -> f32\r\n{\r\n	var center: vec3<f32> = 0.5 * (lowerLeft + upperRight);\r\n	var r: vec3<f32> = 0.5 * (upperRight - lowerLeft);\r\n	var q: vec3<f32> = abs(p - center) - r;\r\n	return length(max(q, vec3(0.0))) + min(max(q.x, max(q.y, q.z)), 0.0);\r\n}\r\n\r\n/* ==================================\r\n * ========= Operations =========\r\n * ==================================\r\n*/\r\n\r\n// Intersection from IQ\r\nfn sdfIntersection(sdfA: f32, sdfB: f32) -> f32\r\n{\r\n	return max(sdfA, sdfB);\r\n}\r\n\r\n// Remap a value in one range to a different range\r\nfn remap(val: f32, oldMin: f32, oldMax: f32, newMin: f32, newMax: f32) -> f32\r\n{\r\n	return newMin + (newMax - newMin) * ((val - oldMin) / (oldMax - oldMin));\r\n}\r\n\r\n/* ============================================\r\n * ======== Heightfield calculations ==========\r\n * ============================================\r\n*/\r\n\r\n// Read height from the heightfield texture given a world point\r\n// returns height at point\r\nfn getTerrainElevation(p: vec2<f32>) -> f32\r\n{\r\n    // calculate the uv value between 0 and 1\r\n	var numerator: vec2<f32> = p - terrain.lowerLeft;       // lower left to current point\r\n	var denom: vec2<f32> = terrain.upperRight - terrain.lowerLeft;  // full range\r\n	var uv: vec2<f32> = numerator / denom;    // remap the vec2 point to a 0->1 range\r\n\r\n    var heightCol : vec4<f32> = textureSampleLevel(heightfield, heightFieldSampler, uv, 0.0);\r\n    var height : f32 = heightCol.r; // black and white means same colour in all channels\r\n    \r\n    // this is between 0 and 1 --> remap to correct height range\r\n	return remap(height, 0.0f, 1.0f, heightRange.x, heightRange.y);\r\n}\r\n\r\n/* ============================================\r\n * ============ Main Raymarching ==============\r\n * ============================================\r\n*/\r\n\r\n// Signed distance field object\r\n// returns signed distance value for the terrain at the point p.\r\nfn terrainSdf(p: vec3<f32>) -> f32 {\r\n	var t : f32 = p.y - getTerrainElevation(p.xz);\r\n	var delta : f32 = 0.1f * (heightRange.y - heightRange.x);\r\n    \r\n    var boxSdf: f32 = sdfBox3D(p, \r\n                                vec3(terrain.lowerLeft.x, heightRange.x - delta, terrain.lowerLeft.y),\r\n                                vec3(terrain.upperRight.x, heightRange.y + delta, terrain.upperRight.y));\r\n\r\n    return sdfIntersection(boxSdf, t);\r\n}\r\n\r\nfn raymarchTerrain(ray: Ray) -> RaymarchResult\r\n{\r\n    var result : RaymarchResult;\r\n    result.hit = false;\r\n    result.t = -1;\r\n\r\n    var aabbTest = intersectAABB(ray);\r\n\r\n    if (!aabbTest.hit)\r\n    {\r\n        // didn't hit AABB\r\n        // def not hitting terrain\r\n        return result;\r\n    }\r\n\r\n    var t : f32 = max(MIN_DIST, aabbTest.tNear);        // start at the point of intersection with the AABB, don't waste unnecessary marching steps\r\n    var dist : f32 = 0;\r\n    var p: vec3<f32>;\r\n    \r\n    // Lipschitz bound is dependent on ray direction\r\n	var uz: f32 = abs(ray.direction.y);\r\n	var kr: f32 = uz + K * sqrt(1.0f - (uz * uz));\r\n\r\n    for (var i : i32 = 0; i<MAX_ITERS; i++)\r\n    {\r\n        if (t > aabbTest.tFar)\r\n        {\r\n            // passed the AABB and didn't hit anything\r\n            // stop raymarching\r\n            break;\r\n        }\r\n\r\n        p = ray.origin + ray.direction * t;\r\n\r\n        dist = terrainSdf(p);\r\n\r\n        if (dist < 0.0f && !result.hit)\r\n        {\r\n            result.hit = true;\r\n            result.t = t;\r\n            result.hitPoint = p;\r\n\r\n            break;\r\n        }\r\n\r\n        if (dist >= MAX_DIST)\r\n        {\r\n            break;\r\n        }\r\n\r\n        t += max(dist / kr, MIN_DIST);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/* ============================================\r\n * ================= Shading ==================\r\n * ============================================\r\n*/\r\n\r\nfn computeNormal(p: vec3<f32>, eps: vec2<f32>) -> vec3<f32>\r\n{\r\n    var e: vec3<f32> = vec3(eps.x, 0.0, eps.y);\r\n    return normalize(vec3(getTerrainElevation(p.xz + e.xy) - getTerrainElevation(p.xz - e.xy),\r\n                            getTerrainElevation(p.xz + e.yz) - getTerrainElevation(p.xz - e.yz),\r\n                            length(eps)\r\n    ));\r\n}\r\n\r\nfn getTerrainColour(p: vec3<f32>) -> vec4<f32>\r\n{\r\n    // TODO: texture size should probably be higher when we get it from the CPU\r\n	// Terrain sides and bottom\r\n	if (abs(sdfBox2D(p.xz, terrain.lowerLeft, terrain.upperRight)) < EPSILON\r\n        || abs(p.y - heightRange.x + 0.1f * (heightRange.y - heightRange.x)) < EPSILON)\r\n    {\r\n        return vec4(0.3f, 0.29f, 0.31f, 1.0f);\r\n    }\r\n	\r\n    var shadingMode = terrain.shadingMode;\r\n\r\n	// Terrain interior\r\n	if (shadingMode == 0)   // normals\r\n	{\r\n        var n: vec3<f32> = computeNormal(p, vec2(EPSILON));//(terrain.upperRight - terrain.lowerLeft) / vec2<f32>(terrain.textureSize));\r\n		return vec4(0.2 * (vec3(3.0) + 2.0 * n.xyz), 1.0);\r\n	}\r\n	else if (shadingMode == 1)  // lambertian\r\n	{\r\n		var lightDir: vec3<f32> = normalize(vec3(0,0,0) - lightPos); // terrain located at world 0,0,0\r\n        var ambientTerm: f32 = 0.2;\r\n        var n: vec3<f32> = computeNormal(p, vec2(EPSILON));//(terrain.upperRight - terrain.lowerLeft) / vec2<f32>(terrain.textureSize));\r\n        var lambertianTerm: vec3<f32> = vec3(max(dot(n, lightDir), 0.0f) + ambientTerm);\r\n        \r\n        var col: vec3<f32> = vec3(1,1,1);\r\n		return vec4(lambertianTerm * col, 1.0f);\r\n	}\r\n	else\r\n    {\r\n		return vec4(1.0, 1.0, 1.0, 1.0);\r\n    }\r\n}\r\n\r\n@fragment\r\nfn frag_main(@location(0) fs_UV : vec2<f32>) -> @location(0) vec4<f32>\r\n{\r\n    var ray : Ray = rayCast(fs_UV);\r\n    var raymarchResult : RaymarchResult = raymarchTerrain(ray);\r\n    var outColor : vec4<f32> = vec4(0,0,0.2,1);\r\n\r\n    if (raymarchResult.hit)\r\n    {\r\n        // outColor = terrainColor;\r\n        outColor = getTerrainColour(raymarchResult.hitPoint);\r\n    }\r\n\r\n    // outColor = vec4((uniforms.right), 1);\r\n\r\n    return outColor;\r\n}\r\n",H),W=X.createSampler({magFilter:"linear",minFilter:"linear"}),K=X.createBuffer({size:400,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),Q=X.createBuffer({size:284,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});y.forEach(async e=>{r=await fetch("assets/heightfields/"+e+".png"),t=await createImageBitmap(await r.blob()),_.push(createTextureFromImage(X,t,!1,!0,"hf_".concat(e)))}),P.forEach(async e=>{r=await fetch(w+e+".png"),t=await createImageBitmap(await r.blob()),T.push(createTextureFromImage(X,t,!1,!0,"uplift_".concat(e)))});let Z=R.map(async e=>await createTextureFromImageWithMip(X,"".concat(w).concat(e,".png"),{mips:!0,flipY:!1}));n=(U=await Promise.all(Z))[0];let J=X.createComputePipeline({layout:"auto",compute:{module:X.createShaderModule({code:"struct SimulationParams {\n  nx         : f32,     // array dimension\n  ny         : f32,\n  lowerVertX : f32,     // lower and upper vertices of the box of the heightfield\n  lowerVertY : f32,\n  upperVertX : f32,\n  upperVertY : f32,\n  cellDiagX  : f32,     // cell diagonal\n  cellDiagY  : f32,\n}\n\nstruct CustomBrushParams {\n  brushPosX     : f32,\n  brushPosY     : f32,\n  brushScale    : f32,\n  brushStrength : f32,\n  erase         : f32,  // temp boolean to erase terrain\n  useCustomBrush: f32,  // boolean\n  streamPower   : f32,\n  // TODO: rotation\n}\n\nstruct AABB {\n  lowerLeft   : vec2<f32>,\n  upperRight  : vec2<f32>,\n}\n\nstruct StreamBuffer {\n  data : array<f32>,\n}\n\n// Uniforms\n@group(0) @binding(0) var<uniform> simParams : SimulationParams;\n\n@group(1) @binding(1) var inElevation : texture_2d<f32>;\n@group(1) @binding(2) var outElevation : texture_storage_2d<rgba8unorm, write>;\n@group(1) @binding(3) var inUplift : texture_2d<f32>;\n@group(1) @binding(4) var outUplift : texture_storage_2d<rgba8unorm, write>;\n// @group(1) @binding(5) var inStream : texture_2d<f32>;\n// @group(1) @binding(6) var outStream : texture_storage_2d<rgba8unorm, write>;\n@group(1) @binding(5) var<storage, read> inStream : StreamBuffer;\n@group(1) @binding(6) var<storage, read_write> outStream : StreamBuffer;\n@group(1) @binding(7) var<storage, read_write> steepestFlowBuffer : array<i32>;\n\n@group(2) @binding(0) var<uniform> customBrushParams : CustomBrushParams;\n@group(2) @binding(1) var customBrush : texture_2d<f32>;\n\n\n// ----------- Global parameters -----------\n// 0: Stream power\n// 1: Stream power + Hillslope (Laplacian)\n// 2: Stream power + Hillslope (Laplacian) + Debris slope\nconst erosionMode : i32 = 2;\n\nconst uplift : f32 = 0.005;//0.01;\nconst k : f32 = 0.05;//0.0005;\nconst k_d : f32 = 10.0;\nconst k_h : f32 = 3.0;//2.0;\nconst p_sa : f32 = 1.0;//0.8;\nconst p_sl : f32 = 1.0;//2.0;\nconst dt : f32 = 2.0;//1.0;\n\n// next 8 neighboring cells\nconst neighbors : array<vec2i, 8> = array<vec2i, 8>(\n  vec2i(0, 1), vec2i(1, 1), \n  vec2i(1, 0), vec2i(1, -1), \n  vec2i(0, -1), vec2i(-1, -1), \n  vec2i(-1, 0), vec2i(-1, 1)\n);\n\n// ----------- Utilities -----------\nfn ToIndex1D(i : i32, j : i32) -> i32 { return i + i32(simParams.nx) * j; }\n\nfn ToIndex1DFromCoord(p : vec2i) -> i32 { return p.x + i32(simParams.nx) * p.y; }\n\nfn Height(p : vec2i) -> f32 {\n    let color = textureLoad(inElevation, vec2u(p), 0);\n    return color.r;\n}\n\nfn UpliftAt(p : vec2i) -> f32 {\n    var color = textureLoad(inUplift, vec2u(p), 0);\n\n    var pf = vec2f(p);\n    if (customBrushParams.brushPosX != -1 && customBrushParams.brushPosY != -1) {\n      if (customBrushParams.useCustomBrush == 1) {\n        color.r = DrawBrush(pf, color.r);\n      }\n      else {\n        color.r = DrawPaint(pf, color.r);\n      }\n    }\n\n    textureStore(outUplift, p, vec4f(vec3f(color.r), 1.f));\n    return color.r; // also greyscale?\n}\n\nfn StreamAt(p : vec2i) -> f32 {\n    // let color = textureLoad(inStream, vec2u(p), 0);\n    // return color.r; // also greyscale?\n    return min(inStream.data[ToIndex1DFromCoord(p)], customBrushParams.streamPower * simParams.nx/256.0);\n}\n\nfn ArrayPoint(p : vec2i) -> vec2f {\n  let lowerVert = vec2f(simParams.lowerVertX, simParams.lowerVertY);\n  let cellDiag = vec2f(simParams.cellDiagX, simParams.cellDiagY);\n  return lowerVert + vec2f(p) * cellDiag;\n}\n\nfn Point3D(p : vec2i) -> vec3f {\n  return vec3f(ArrayPoint(p), Height(p));\n}\n\nfn Slope(p : vec2i, q : vec2i) -> f32 {\n  let nx = i32(simParams.nx);\n  let ny = i32(simParams.ny);\n  if (p.x < 0 || p.x >= nx || p.y < 0 || p.y >= ny) { return 0.0; }\n  if (q.x < 0 || q.x >= nx || q.y < 0 || q.y >= ny) { return 0.0; }\n  if (p.x == q.x && p.y == q.y) { return 0.0; }\n\n  var d = length(ArrayPoint(q) - ArrayPoint(p));\n  return (Height(q) - Height(p)) / d;\n}\n\nfn SetFlowSteepest(i: i32, idx: i32)\n{\n  steepestFlowBuffer[i] = idx;\n}\n\nfn GetFlowSteepest(p : vec2i, id: i32) -> vec2i {\n  var d = vec2();\n  var idx: i32;\n  var maxSlope = 0.0;\n  for (var i = 0; i < 8; i++) {\n      var ss = Slope(p + neighbors[i], p);\n      if (ss > maxSlope) {\n        maxSlope = ss;\n        d = neighbors[i];\n        idx = i;\n      }\n  }\n\n  SetFlowSteepest(id, idx);\n  return d;\n}\n\nfn GetFlowSteepestFast(i : i32) -> vec2i {\n  return neighbors[steepestFlowBuffer[i]];\n}\n\nfn Stream(p : vec2i) -> f32 {\n  if (p.x < 0 || p.x >= i32(simParams.nx) || p.y < 0 || p.y >= i32(simParams.ny)) { return 0.0; }\n  \n  return StreamAt(p);\n}\n\nfn WaterSteepest(p : vec2i, id: i32) -> f32 {\n  var water = 0.0;\n  for (var i = 0; i < 8; i++) {\n      var q = p + neighbors[i];\n      var fd = vec2i(0);\n      if (false)\n      {\n        fd = GetFlowSteepestFast(ToIndex1DFromCoord(q));\n      }\n      else\n      {\n        fd = GetFlowSteepest(q, id);\n      }\n      if ((q + fd).x == p.x && (q + fd).y == p.y) {\n        water += Stream(q);\n      }\n  }\n  return water;\n}\n\nfn Laplacian(p : vec2i) -> f32 {\n  var laplacian = 0.0;\n  var i : i32 = p.x;\n  var j : i32 = p.y;\n\n  var sqrCellDiagX = simParams.cellDiagX * simParams.cellDiagX;\n  var sqrCellDiagY = simParams.cellDiagY * simParams.cellDiagY;\n\n  if (i == 0) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i+1, j)) + Height(vec2i(i+2, j))) / sqrCellDiagX;\n  }\n  else if (i == i32(simParams.nx) - 1) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i-1, j)) + Height(vec2i(i-2, j))) / sqrCellDiagX;\n  }\n  else {\n    laplacian += (Height(vec2i(i+1, j)) - 2.0 * Height(vec2i(i, j)) + Height(vec2i(i-1, j))) / sqrCellDiagX;\n  }\n  \n  if (j == 0) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i, j+1)) + Height(vec2i(i, j+2))) / sqrCellDiagY;\n  }\n  else if (j == i32(simParams.ny) - 1) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i, j-1)) + Height(vec2i(i, j-2))) / sqrCellDiagY;\n  }\n  else {\n    laplacian += (Height(vec2i(i, j+1)) - 2.0 * Height(vec2i(i, j)) + Height(vec2i(i, j-1))) / sqrCellDiagY;\n  }\n\n  return laplacian;\n}\n\nfn Read(p : vec2i) -> vec4f {\n  if (p.x < 0 || p.x >= i32(simParams.nx) || p.y < 0 || p.y >= i32(simParams.ny)) {\n    return vec4f();\n  }\n\n  var ret = vec4f();\n  ret.x = Height(p);        // Bedrock elevation\n  ret.y = StreamAt(p);      // Stream area\n  ret.z = UpliftAt(p);      // Uplift factor\n  return ret;\n}\n\nfn Write(p : vec2i, data : vec4f) {\n  textureStore(outElevation, p, vec4f(data.x));\n  // textureStore(outStream, p, vec4f(data.y));\n  outStream.data[ToIndex1DFromCoord(p)] = data.y;\n}\n\n// Local Editing\nfn DrawPaint(pf : vec2f, colorChannel : f32) -> f32 {\n      var brushScale = f32(simParams.nx)/256.0; \n\n  var PAINT_STRENGTH = customBrushParams.brushStrength * 0.02* brushScale;\n  var PAINT_RADIUS = customBrushParams.brushScale * 2.0* brushScale; // scale up for now as brush texture is using this as mip level\n\n  var dist = distance(vec2f(customBrushParams.brushPosX, customBrushParams.brushPosY), pf);\n  if (dist <= PAINT_RADIUS) {\n    var factor = 1.0 - dist * dist / (PAINT_RADIUS * PAINT_RADIUS);\n    if (customBrushParams.erase == 1) {\n      return colorChannel - PAINT_STRENGTH * factor * factor * factor;\n    }\n    else {\n      return colorChannel + PAINT_STRENGTH * factor * factor * factor;\n    }\n  }\n\n  return colorChannel;\n}\n\nfn GetBrushAABB() -> AABB {\n  var center = vec2f(customBrushParams.brushPosX, customBrushParams.brushPosY);\n  var halfWidth = f32(textureDimensions(customBrush).x / 2);\n  var halfHeight = f32(textureDimensions(customBrush).y / 2);\n  var scale = 1 + customBrushParams.brushScale;\n\n  var lowerLeft = vec2f(center.x - halfWidth / scale, center.y - halfHeight / scale);\n  var upperRight = vec2f(center.x + halfWidth / scale, center.y + halfHeight / scale);\n  return AABB(lowerLeft, upperRight);\n}\n\nfn DrawBrush(pf : vec2f, colorChannel : f32) -> f32 {\n  var bb = GetBrushAABB();\n  var minX = bb.lowerLeft.x;\n  var minY = bb.lowerLeft.y;\n  var maxX = bb.upperRight.x;\n  var maxY = bb.upperRight.y;\n  var withinBB = minX < pf.x && pf.x < maxX &&\n                  minY < pf.y && pf.y < maxY;\n  if (withinBB) {\n    // var texCoordf = vec2f((pf.x - minX) / f32(textureDimensions(customBrush).x),\n    //                       (pf.y - minY) / f32(textureDimensions(customBrush).y));\n    var pixelIdx = vec2u(u32(pf.x - minX), u32(pf.y - minY));\n\n    var strength = customBrushParams.brushStrength * 0.1; // scale down strength for now, testing\n    if (customBrushParams.erase == 1) {\n      // use brushScale as mip level; use b channel from sampled value\n      return colorChannel - textureLoad(customBrush, pixelIdx, u32(customBrushParams.brushScale)).b * strength;\n      // color.g -= textureSampleLevel(customBrush, brushSampler, texCoordf, customBrushParams.brushScale).b / customBrushParams.brushStrength;\n    }\n    else {\n      return colorChannel + textureLoad(customBrush, pixelIdx, u32(customBrushParams.brushScale)).b * strength;\n      // color.g += textureSampleLevel(customBrush, brushSampler, texCoordf, customBrushParams.brushScale).b / customBrushParams.brushStrength;\n    }\n  }\n\n  return colorChannel;      \n}\n\n@compute @workgroup_size(8, 8, 1)\nfn main(\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let idX = i32(GlobalInvocationID.x);\n  let idY = i32(GlobalInvocationID.y);\n\n  var id : i32 = ToIndex1D(idX, idY);\n  var p : vec2i = vec2i(idX, idY);\n  var data : vec4f = Read(p);\n  var cellDiag = vec2f(simParams.cellDiagX, simParams.cellDiagY);\n\n  var newHeight = 0.0;\n  var borderNode: bool = false;\n  var d: vec2i;\n  // Border nodes are fixed to zero (elevation and drainage)\n  if (p.x == 0 || p.x == i32(simParams.nx) - 1 ||\n      p.y == 0 || p.y == i32(simParams.ny) - 1) {\n    data.x = 0.0;\n    data.y = 1.0 * length(cellDiag);\n    Write(p, data);\n    borderNode = true;\n  }\n  else\n  {\n    // Erosion at p (relative to steepest)\n    d = GetFlowSteepest(p, id);\n  }\n\n  workgroupBarrier(); // workgroup barrier must happen in uniform control flow\n\n  if (idX < 0 || idY < 0) { return; }\n  if (idX >= i32(simParams.nx) || idY >= i32(simParams.ny)) { return; }\n\n  if (borderNode)\n  {\n    return;\n  }\n\n  // Flows accumulation at p\n  var waterIncr = WaterSteepest(p, id);\n\n  data.y = 1.0 * length(cellDiag);\n  data.y += waterIncr;\n\n  var receiver = Read(p + d);\n  var pSlope = abs(Slope(p + d, p));\n\n  var erosion = k * pow(data.y, p_sa) * pow(pSlope, p_sl);\n\n  newHeight = data.x;\n  if (erosionMode == 0) {           // Stream power\n    newHeight -= dt * (erosion);\n  }\n  else if (erosionMode == 1) {      // Stream power + Hillslope erosion (Laplacian)\n    newHeight -= dt * (erosion - k_h * Laplacian(p));\n  }\n  else if (erosionMode == 2) {      // Stream power + Hillslope erosion (Laplacian) + Debris flow\n    newHeight -= dt * (erosion - k_h * Laplacian(p) - k_d * pSlope);\n  }\n\n  newHeight = max(newHeight, receiver.x);\n  newHeight += dt * uplift * data.z;\n\n  data.x = newHeight;\n  Write(p, data);\n}"}),entryPoint:"main"}}),$=X.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),ee=X.createBindGroup({label:"simulation constants",layout:J.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:$}}]}),er=X.createBuffer({size:28,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),et={label:"brush bind group descriptor",layout:J.getBindGroupLayout(2),entries:[{binding:0,resource:{buffer:er}},{binding:1,resource:n.createView()}]},en=X.createBindGroup(et),ei=new b,ea={colorAttachments:[{view:void 0,clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]};function renderTerrain(e){e.setPipeline(k),writeMVPUniformBuffer(X,K,0,o.getModelMatrix(),j,!0),writeTerrainUniformBuffer(X,Q,ei,S.indexOf(p.shadingMode)),e.setBindGroup(0,o.bindGroup),e.setIndexBuffer(o.indexBuffer,"uint32"),e.setVertexBuffer(0,o.posBuffer),e.setVertexBuffer(1,o.normalBuffer),e.setVertexBuffer(2,o.uvBuffer),e.drawIndexed(o.count)}function renderQuad(e){e.setPipeline(z),writeMVPUniformBuffer(X,K,256,a.getModelMatrix(),j,!0),e.setBindGroup(0,a.bindGroup),e.setIndexBuffer(a.indexBuffer,"uint32"),e.setVertexBuffer(0,a.posBuffer),e.setVertexBuffer(1,a.normalBuffer),e.setVertexBuffer(2,a.uvBuffer),e.drawIndexed(a.count)}requestAnimationFrame(function frame(){if(!c.active)return;G?function(){let e,r,t,n,i=j.resolution[0]/window.devicePixelRatio,a=j.resolution[1]/window.devicePixelRatio,o=function(e,r,t,n,i){let a=141.3716694115407/180,o=s.R3.mulScalar(e.up,Math.tan(.5*a)),u=s.R3.mulScalar(e.right,Math.tan(.5*a)*(r/t)),f=s.R3.add(s.R3.add(e.getPosition(),e.forward),s.R3.mulScalar(u,2*n/r-1));s.R3.add(f,s.R3.mulScalar(o,2*i/t-1),f);let l=s.R3.sub(f,e.getPosition());return s.R3.normalize(l)}(j,i,a,A,D),u=s.R3.create(j.getPosition()[0],j.getPosition()[1],j.getPosition()[2]),[f,l]=(e=s.vh.create(0,1,0,0),r=s.vh.create(0,0,0,0),t=s.R3.dot(e,s.R3.sub(r,u))/s.R3.dot(e,o),n=s.R3.add(u,s.R3.mulScalar(o,t)),t<0||n[0]<ei.lowerVertX||n[0]>ei.upperVertX||n[2]<ei.lowerVertY||n[2]>ei.upperVertY?[!1,null]:[!0,n]),c=-1,d=-1;if(f){let e=s.R3.sub(s.R3.create(l[0],l[1],l[2]),s.R3.create(ei.lowerVertX,0,ei.lowerVertY)),r=s.R3.sub(s.R3.create(ei.upperVertX,0,ei.upperVertY),s.R3.create(ei.lowerVertX,0,ei.lowerVertY)),t=s.R3.div(e,r);c=Math.floor(t[0]*C[V].width),d=Math.floor(t[2]*C[V].height)}E[0]=c,E[1]=d}():(j.update(),E[0]=-1,E[1]=-1),h.begin();let e=X.createCommandEncoder();if(g>-1){if(0==g||1==g){let n,s;if(C[0]&&C[1]&&(C[0].destroy(),C[1].destroy(),I[0].destroy(),I[1].destroy(),M[0].destroy(),M[1].destroy(),i.destroy()),L)n=createTextureFromImage(X,F,!1,!0);else{let e=0;_.forEach(function(r,t){r.label=="hf_".concat(p.heightfield)&&(e=t)}),n=_[e],F&&F.close()}{let e=0;T.forEach(function(r,t){r.label=="uplift_".concat(p.uplift)&&(e=t)}),s=T[e]}var r=n.width,t=n.height;C=[0,1].map(e=>createTextureOfSize(X,r,t,!1,"hf_".concat(p.heightfield,"_").concat(e))),I=[0,1].map(e=>createTextureOfSize(X,s.width,s.height,!1,"uplift_".concat(p.uplift,"_").concat(e))),M=[0,1].map(()=>{let e=X.createBuffer({size:r*t*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return X.queue.writeBuffer(e,0,new Float32Array(t*r)),e}),i=X.createBuffer({size:r*t*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE}),X.queue.writeBuffer(i,0,new Uint32Array(t*r)),o.bindGroupCreated=!1,a.bindGroupCreated=!1,e.copyTextureToTexture({texture:n},{texture:C[V]},{width:r,height:t}),e.copyTextureToTexture({texture:s},{texture:I[V]},{width:s.width,height:s.height})}2==g&&(et.entries[1].resource=n.createView(),en=X.createBindGroup(et)),Y=!0,g=-1}o.createTerrainBindGroup(k,K,0,W,C[V],Q),a.createBindGroup(z,K,256,W,C[V]),Y&&p.useRenderBundles&&(function(){let e=X.createRenderBundleEncoder({colorFormats:[H]});renderTerrain(e),u=e.finish()}(),function(){let e=X.createRenderBundleEncoder({colorFormats:[H]});renderQuad(e),f=e.finish()}(),Y=!1);{let r={label:"compute bind group descriptor curr",layout:J.getBindGroupLayout(1),entries:[{binding:1,resource:C[V].createView()},{binding:2,resource:C[(V+1)%2].createView()},{binding:3,resource:I[V].createView()},{binding:4,resource:I[(V+1)%2].createView()},{binding:5,resource:{buffer:M[V]}},{binding:6,resource:{buffer:M[(V+1)%2]}},{binding:7,resource:{buffer:i}}]},t=X.createBindGroup(r),n=e.beginComputePass();n.setPipeline(J),X.queue.writeBuffer($,0,new Float32Array([C[V].width,C[V].height,ei.lowerVertX,ei.lowerVertY,ei.upperVertX,ei.upperVertY,ei.cellDiagX,ei.cellDiagY]));let a=0,o=0;p.eraseTerrain&&(a=1),p.useCustomBrush&&(o=1),X.queue.writeBuffer(er,0,new Float32Array([E[0],E[1],o?10-p.brushScale:p.brushScale,p.brushStrength,a,o,p.streamPower])),n.setBindGroup(0,ee),n.setBindGroup(1,t),n.setBindGroup(2,en),n.dispatchWorkgroups(Math.ceil(Math.max(C[V].width,C[V].height)/8)+1,Math.ceil(Math.max(C[V].width,C[V].height)/8)+1),n.end(),V=(V+1)%2}if(p.useRenderBundles){ea.colorAttachments[0].view=O.getCurrentTexture().createView();let r=e.beginRenderPass(ea);r.executeBundles([u,f]),renderTerrain(r),renderQuad(r),r.end()}else{let r=e.beginRenderPass({colorAttachments:[{view:O.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});r.setPipeline(k),writeMVPUniformBuffer(X,K,0,o.getModelMatrix(),j,!0),writeTerrainUniformBuffer(X,Q,ei,S.indexOf(p.shadingMode)),r.setBindGroup(0,o.bindGroup),r.setIndexBuffer(o.indexBuffer,"uint32"),r.setVertexBuffer(0,o.posBuffer),r.setVertexBuffer(1,o.normalBuffer),r.setVertexBuffer(2,o.uvBuffer),r.drawIndexed(o.count),r.end()}if(!p.useRenderBundles){let r=e.beginRenderPass({colorAttachments:[{view:O.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"load",storeOp:"store"}]});r.setPipeline(z),writeMVPUniformBuffer(X,K,256,a.getModelMatrix(),j,!0),r.setBindGroup(0,a.bindGroup),r.setIndexBuffer(a.indexBuffer,"uint32"),r.setVertexBuffer(0,a.posBuffer),r.setVertexBuffer(1,a.normalBuffer),r.setVertexBuffer(2,a.uvBuffer),r.drawIndexed(a.count),r.end()}X.queue.submit([e.finish()]),requestAnimationFrame(frame),h.end()})};var pages=()=>makeSample({name:"Terrain X",description:"Interactive terrain authoring and erosion simulation on WebGPU",gui:!0,stats:!0,init,filename:"src/sample/terrainX/main.ts"})},4131:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__ZTWP5"}}},function(e){e.O(0,[746,150,774,888,179],function(){return e(e.s=8312)}),_N_E=e.O()}]);