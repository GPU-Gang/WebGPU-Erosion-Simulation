(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[405],{8312:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return n(9822)}])},9822:function(e,t,n){"use strict";let r,i,a,o;n.r(t),n.d(t,{default:function(){return pages}});var s,u,c,l,f,h,p=n(6416),d=n(5893),g=n(9008),m=n.n(g),v=n(7294),x=n(4131),b=n.n(x);let SampleLayout=e=>{let t=(0,v.useRef)(null),r=(0,v.useRef)(null),i=(0,v.useMemo)(()=>{if(e.gui){let e=n(4376);return new e.GUI({autoPlace:!1})}},[]),a=(0,v.useRef)(null),o=(0,v.useMemo)(()=>{if(e.stats){let e=n(2792);return new e}},[]),[s,u]=(0,v.useState)(null);return(0,v.useEffect)(()=>{if(i&&r.current)for(r.current.appendChild(i.domElement);i.__controllers.length>0;)i.__controllers[0].remove();o&&a.current&&(o.dom.style.position="absolute",o.showPanel(1),a.current.appendChild(o.dom));let n={active:!0};try{let r=t.current;if(!r)throw Error("The canvas is not available");let a=e.init({canvas:r,pageState:n,gui:i,stats:o});a instanceof Promise&&a.catch(e=>{console.error(e),u(e)})}catch(e){console.error(e),u(e)}return()=>{n.active=!1}},[]),(0,d.jsxs)("main",{children:[(0,d.jsxs)(m(),{children:[(0,d.jsx)("title",{children:"Terrain X"}),(0,d.jsx)("meta",{name:"description",content:e.description}),(0,d.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,d.jsxs)("div",{children:[(0,d.jsx)("h1",{children:e.name}),(0,d.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://github.com/".concat("GPU-Gang/WebGPU-Erosion-Simulation","/tree/main/").concat(e.filename),children:"See it on Github!"}),(0,d.jsx)("p",{children:e.description}),s?(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)("p",{children:"Something went wrong. Do your browser and device support WebGPU?"}),(0,d.jsx)("p",{children:"".concat(s)})]}):null]}),(0,d.jsxs)("div",{className:b().canvasContainer,children:[(0,d.jsx)("div",{style:{position:"absolute",left:10},ref:a}),(0,d.jsx)("div",{style:{position:"absolute",right:10},ref:r}),(0,d.jsx)("canvas",{ref:t})]})]})},makeSample=e=>(0,d.jsx)(SampleLayout,{...e});var w=n(4478),y=class{setResolution(e){this.resolution=e,this.aspectRatio=e[0]/e[1]}updateProjectionMatrix(){p._E.perspective(this.fovy,this.aspectRatio,this.near,this.far,this.projectionMatrix)}update(){this.controls.tick();let e=this.viewMatrix();this.right[0]=-e[0],this.right[1]=-e[4],this.right[2]=-e[8],this.up[0]=e[1],this.up[1]=e[5],this.up[2]=e[9],this.forward[0]=-e[2],this.forward[1]=-e[6],this.forward[2]=-e[10]}viewMatrix(){return this.controls.matrix}getPosition(){return this.controls.eye}constructor(e,t){this.projectionMatrix=p._E.create(),this.fovy=45,this.aspectRatio=1,this.near=.1,this.far=1e6,this.resolution=p.K4.create(400,400),this.right=p.R3.create(1,0,0),this.up=p.R3.create(0,1,0),this.forward=p.R3.create(0,0,1),this.controls=w(document.getElementById("canvas"),{eye:e,center:t,translateSpeed:-1,mode:"orbit"}),this.controls.flipX=!0,this.controls.flipY=!0,this.controls.rotate(0,3.14159,0)}},B=class{create(e){this.device=e}createIndexBuffer(){return this.idxBound||(this.idxBound=!0,this.indexBuffer=this.device.createBuffer({size:this.indices.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),new Uint32Array(this.indexBuffer.getMappedRange()).set(this.indices),this.indexBuffer.unmap()),this.indexBuffer}createPosBuffer(){return this.posBound||(this.posBound=!0,this.posBuffer=this.device.createBuffer({size:this.positions.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.posBuffer.getMappedRange()).set(this.positions),this.posBuffer.unmap()),this.posBuffer}createNormalBuffer(){return this.norBound||(this.norBound=!0,this.normalBuffer=this.device.createBuffer({size:this.normals.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.normalBuffer.getMappedRange()).set(this.normals),this.normalBuffer.unmap()),this.normalBuffer}createUVBuffer(){return this.uvBound||(this.uvBound=!0,this.uvBuffer=this.device.createBuffer({size:this.uvs.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.uvBuffer.getMappedRange()).set(this.uvs),this.uvBuffer.unmap()),this.uvBuffer}elemCount(){return this.count}constructor(){this.count=0,this.idxBound=!1,this.posBound=!1,this.norBound=!1,this.uvBound=!1}};function degToRad(e){return .0174533*e}var P=class extends B{create(e){super.create(e),this.indices=new Uint32Array([0,1,2,0,2,3]),this.normals=new Float32Array([0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0]),this.positions=new Float32Array([-1,-1,0,1,1,-1,0,1,1,1,0,1,-1,1,0,1]),this.uvs=new Float32Array([0,1,1,1,1,0,0,0]),this.count=this.indices.length,this.createIndexBuffer(),this.createPosBuffer(),this.createNormalBuffer(),this.createUVBuffer()}createBindGroup(e,t,n,r,i){return this.bindGroupCreated||(this.bindGroupCreated=!0,this.bindGroup=this.device.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t,offset:n}},{binding:1,resource:r},{binding:2,resource:i.createView()}]})),this.bindGroup}getModelMatrix(){let e=p._E.identity();return p._E.rotateX(e,this.rotation[0],e),p._E.rotateY(e,this.rotation[1],e),p._E.rotateZ(e,this.rotation[2],e),p._E.scale(e,this.scale,e),p._E.translate(e,this.center,e),e}constructor(e=p.vh.create(0,0,0,0),t=p.R3.create(1,1,1),n=p.R3.create(0,0,0)){super(),this.bindGroupCreated=!1,this.center=p.vh.fromValues(e[0],e[1],e[2],1),this.scale=t,this.rotation=n,this.rotation[0]=degToRad(this.rotation[0]),this.rotation[1]=degToRad(this.rotation[1]),this.rotation[2]=degToRad(this.rotation[2])}},R=class extends P{createTerrainBindGroup(e,t,n,r,i,a){return this.bindGroupCreated||(this.bindGroupCreated=!0,this.bindGroup=this.device.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t,offset:n}},{binding:1,resource:r},{binding:2,resource:i.createView()},{binding:3,resource:{buffer:a,offset:0}}]})),this.bindGroup}},T=class{constructor(){this.nx=256,this.ny=256,this.lowerVertX=-5,this.lowerVertY=-5,this.upperVertX=5,this.upperVertY=5,this.cellDiagX=1176.47,this.cellDiagY=1176.47}};let _="assets/heightfields/",S="assets/uplifts/",I=["hfTest1","hfTest2"],A=["alpes_noise","lambda"],U=["pattern1","pattern2","pattern3"];(s=l||(l={}))[s.hfTest1=0]="hfTest1",s[s.hfTest2=1]="hfTest2",(u=f||(f={}))[u.alpes_noise=0]="alpes_noise",u[u.lambda=1]="lambda",(c=h||(h={}))[c.pattern1=0]="pattern1",c[c.pattern2=1]="pattern2",c[c.pattern3=2]="pattern3";let D=[],G=[],V=[],E=[],M=0,C=!1,L=0,N=0,H=p.K4.fromValues(-1,-1);function createRenderPipeline(e,t,n){let r=e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:t}),entryPoint:"vert_main",buffers:[{arrayStride:16,attributes:[{shaderLocation:0,format:"float32x4",offset:0}]},{arrayStride:16,attributes:[{shaderLocation:1,format:"float32x4",offset:0}]},{arrayStride:8,attributes:[{shaderLocation:2,format:"float32x2",offset:0}]}]},fragment:{module:e.createShaderModule({code:t}),entryPoint:"frag_main",targets:[{format:n}]},primitive:{topology:"triangle-list",cullMode:"back"}});return r}function writeMVPUniformBuffer(e,t,n,r,i){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=p._E.identity();var s=i.viewMatrix();a?p._E.multiply(o,r,o):(p._E.multiply(s,r,o),p._E.multiply(i.projectionMatrix,o,o)),e.queue.writeBuffer(t,n,new Float32Array([o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],o[8],o[9],o[10],o[11],o[12],o[13],o[14],o[15],i.right[0],i.right[1],i.right[2],0,i.up[0],i.up[1],i.up[2],0,i.forward[0],i.forward[1],i.forward[2],0,i.getPosition()[0],i.getPosition()[1],i.getPosition()[2],0,i.resolution[0],i.resolution[1],0,0]))}let createTextureFromImage=(e,t,n,r,i)=>{let a=e.createTexture({label:i,size:[t.width,t.height,1],format:n?"r8unorm":"rgba8unorm",mipLevelCount:1,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|(!n&&GPUTextureUsage.STORAGE_BINDING)|(!n&&GPUTextureUsage.COPY_SRC)});return r&&e.queue.copyExternalImageToTexture({source:t},{texture:a},[t.width,t.height]),a},init=async e=>{let{canvas:t,pageState:n,gui:s}=e;s.width=280;let u={heightfield:I[0],uplift:A[0],eraseTerrain:!1,useCustomBrush:!1,customBrush:U[0],brushScale:10,brushStrength:10},c=!1,d=!1;s.add(u,"heightfield",I).onFinishChange(()=>{d=!0}),s.add(u,"uplift",A).onFinishChange(()=>{r=G[f[u.uplift]],c=!0}),s.add(u,"eraseTerrain"),s.add(u,"useCustomBrush"),s.add(u,"customBrush",U).onFinishChange(()=>{i=V[h[u.customBrush]],c=!0}),s.add(u,"brushScale",0,100),s.add(u,"brushStrength",0,100);let g=await navigator.gpu.requestAdapter(),m=await g.requestDevice();if(!n.active)return;let v=t.getContext("webgpu"),x=window.devicePixelRatio;t.width=t.clientWidth*x,t.height=t.clientHeight*x,console.log("canvas.clientWidth:",t.clientWidth),console.log("canvas.clientHeight:",t.clientHeight),console.log("devicePixelRatio:",x);let b=navigator.gpu.getPreferredCanvasFormat();t.addEventListener("mousedown",e=>{e.ctrlKey&&0==e.button&&(C=!0,L=e.offsetX,N=e.offsetY)}),t.addEventListener("mouseup",()=>{C=!1}),v.configure({device:m,format:b,alphaMode:"premultiplied"}),(a=new P(p.vh.create(2.5,2.5,0,0),p.R3.create(.3,.3,1))).create(m),(o=new R(p.vh.create(0,0,0,0),p.R3.create(1,1,1))).create(m);let w=p.R3.create(o.center[0],o.center[1]+2,o.center[2]),B=new y(p.R3.create(0,0,-10),w);B.setResolution(p.K4.create(t.width,t.height)),B.updateProjectionMatrix();let F=createRenderPipeline(m,"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n}\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n\n@group(0) @binding(1) var mySampler : sampler;\n@group(0) @binding(2) var myTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fs_UV : vec2<f32>,\n}\n\n@vertex\nfn vert_main(\n  @location(0) vs_pos: vec4<f32>,\n  @location(1) vs_nor: vec4<f32>,\n  @location(2) vs_uv: vec2<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = uniforms.modelViewProjectionMatrix * vs_pos;\n  output.fs_UV = vs_uv;\n  return output;\n}\n\n@fragment\nfn frag_main(@location(0) fs_UV : vec2<f32>) -> @location(0) vec4<f32> {\n  return textureSample(myTexture, mySampler, fs_UV);\n}",b),O=createRenderPipeline(m,"struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n  right: vec3<f32>,\n  up: vec3<f32>,\n  forward: vec3<f32>,\n  eye: vec3<f32>,\n  screenDims: vec2<f32>,\n}\n\nstruct Terrain\n{\n    textureSize: vec2<i32>, // texture size\n    lowerLeft: vec2<f32>,   // AABB\n    upperRight: vec2<f32>,  // AABB\n}\n\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n@group(0) @binding(1) var heightFieldSampler : sampler;\n@group(0) @binding(2) var heightfield : texture_2d<f32>;\n@group(0) @binding(3) var<uniform> terrain : Terrain;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fs_UV : vec2<f32>,\n}\n\n@vertex\nfn vert_main(\n  @location(0) vs_pos: vec4<f32>,\n  @location(1) vs_nor: vec4<f32>,\n  @location(2) vs_uv: vec2<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = uniforms.modelViewProjectionMatrix * vs_pos;\n  output.fs_UV = vs_uv;\n  return output;\n}\n\n// ----------- FRAG SHADER ------------ //\n\nconst PI : f32 = 3.14159265358979323;\nconst FOVY : f32 = 45.0f * PI / 180.0;\nconst MAX_ITERS : i32 = 256;\nconst MIN_DIST : f32 = 0.01f;\nconst MAX_DIST : f32 = 1000000.0f;\nconst EPSILON : f32 = MIN_DIST;\nconst heightRange : vec2<f32> = vec2(0, 1);       // hardcoded range for now\nconst K: f32 = 1.0f;                              // hardcoded Lipschitz constant\nconst lightPos: vec3<f32> = vec3(5, 12, -5);       // light position\n\n// Data structures\nstruct Ray {\n    origin: vec3<f32>,\n    direction: vec3<f32>,\n};\n\nstruct IntersectAABBResult\n{\n    hit: bool,\n    tNear: f32,\n    tFar: f32\n}\n\nstruct RaymarchResult\n{\n    hit: bool,\n    t: f32,\n    hitPoint: vec3<f32>,\n}\n\n/* =================================\n * ========= RAY FUNCTIONS =========\n * =================================\n*/\n\nfn rayCast(fs_UV: vec2<f32>) -> Ray\n{\n    var ndc : vec2<f32> = (fs_UV);\n    ndc = ndc * 2.f - vec2(1.f);\n\n    let aspect : f32 = uniforms.screenDims.x / uniforms.screenDims.y;\n    let reference : vec3<f32> = uniforms.eye + uniforms.forward;\n    let V : vec3<f32> = uniforms.up * tan(FOVY * 0.5);\n    let H : vec3<f32> = uniforms.right * tan(FOVY * 0.5) * aspect;\n    let p : vec3<f32> = reference + H * ndc.x + V * ndc.y;\n\n    return Ray(uniforms.eye, normalize(p - uniforms.eye));\n}\n\nfn intersectAABB(ray: Ray) -> IntersectAABBResult\n{\n    var result : IntersectAABBResult;\n    result.hit = false;\n    result.tNear = -1;\n    result.tFar = -1;\n\n	var rinvDir : vec3<f32> = 1.0 / ray.direction;\n	var delta : f32 = 0.1 * (heightRange.y - heightRange.x);\n	var tbot : vec3<f32> = rinvDir * (vec3(terrain.lowerLeft.x, heightRange.x - delta, terrain.lowerLeft.y) - ray.origin);\n	var ttop : vec3<f32> = rinvDir * (vec3(terrain.upperRight.x, heightRange.y + delta, terrain.upperRight.y) - ray.origin);\n\n	var tmin : vec3<f32> = min(ttop, tbot);\n	var tmax : vec3<f32> = max(ttop, tbot);\n	var t : vec2<f32> = max(tmin.xx, tmin.yz);\n	var t0 : f32 = max(t.x, t.y);\n	t = min(tmax.xx, tmax.yz);\n	var t1 : f32 = min(t.x, t.y);\n\n    result.hit = t1 > max(t0, 0.0);\n    result.tNear = t0;\n    result.tFar = t1;\n\n    return result;\n}\n\n/* ===============================\n * ======== SDF Primitives =======\n * ===============================\n*/\n\nfn sdfSphere(p: vec3<f32>) -> f32\n{\n    return distance(p, vec3(0,0,0)) - 0.257f;\n}\n\nfn sdfBox2D(p: vec2<f32>, lowerLeft: vec2<f32>, upperRight: vec2<f32>) -> f32\n{\n	var center: vec2<f32> = 0.5 * (lowerLeft + upperRight);\n	var r: vec2<f32> = 0.5 * (upperRight - lowerLeft);\n	var q: vec2<f32> = abs(p - center) - r;\n    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0);\n}\n\nfn sdfBox3D(p: vec3<f32>, lowerLeft: vec3<f32>, upperRight: vec3<f32>) -> f32\n{\n	var center: vec3<f32> = 0.5 * (lowerLeft + upperRight);\n	var r: vec3<f32> = 0.5 * (upperRight - lowerLeft);\n	var q: vec3<f32> = abs(p - center) - r;\n	return length(max(q, vec3(0.0))) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n/* ==================================\n * ========= Operations =========\n * ==================================\n*/\n\n// Intersection from IQ\nfn sdfIntersection(sdfA: f32, sdfB: f32) -> f32\n{\n	return max(sdfA, sdfB);\n}\n\n// Remap a value in one range to a different range\nfn remap(val: f32, oldMin: f32, oldMax: f32, newMin: f32, newMax: f32) -> f32\n{\n	return newMin + (newMax - newMin) * ((val - oldMin) / (oldMax - oldMin));\n}\n\n/* ============================================\n * ======== Heightfield calculations ==========\n * ============================================\n*/\n\n// Read height from the heightfield texture given a world point\n// returns height at point\nfn getTerrainElevation(p: vec2<f32>) -> f32\n{\n    // calculate the uv value between 0 and 1\n	var numerator: vec2<f32> = p - terrain.lowerLeft;       // lower left to current point\n	var denom: vec2<f32> = terrain.upperRight - terrain.lowerLeft;  // full range\n	var uv: vec2<f32> = numerator / denom;    // remap the vec2 point to a 0->1 range\n\n    var heightCol : vec4<f32> = textureSample(heightfield, heightFieldSampler, uv);\n    var height : f32 = heightCol.r; // black and white means same colour in all channels\n    \n    // this is between 0 and 1 --> remap to correct height range\n	return remap(height, 0.0f, 1.0f, heightRange.x, heightRange.y);\n}\n\n/* ============================================\n * ============ Main Raymarching ==============\n * ============================================\n*/\n\n// Signed distance field object\n// returns signed distance value for the terrain at the point p.\nfn terrainSdf(p: vec3<f32>) -> f32 {\n	var t : f32 = p.y - getTerrainElevation(p.xz);\n	var delta : f32 = 0.1f * (heightRange.y - heightRange.x);\n    \n    var boxSdf: f32 = sdfBox3D(p, \n                                vec3(terrain.lowerLeft.x, heightRange.x - delta, terrain.lowerLeft.y),\n                                vec3(terrain.upperRight.x, heightRange.y + delta, terrain.upperRight.y));\n\n    return sdfIntersection(boxSdf, t);\n}\n\nfn raymarchTerrain(ray: Ray) -> RaymarchResult\n{\n    var result : RaymarchResult;\n    result.hit = false;\n    result.t = -1;\n\n    var aabbTest = intersectAABB(ray);\n\n    // TODO: find a way to re-enable this optimisation because WebGPU has over strict uniformity analysis\n    // if (!aabbTest.hit)\n    // {\n    //     // didn't hit AABB\n    //     // def not hitting terrain\n    //     return result;\n    // }\n\n    var t : f32 = max(MIN_DIST, aabbTest.tNear);        // start at the point of intersection with the AABB, don't waste unnecessary marching steps\n    var dist : f32 = 0;\n    var p: vec3<f32>;\n    \n    // Lipschitz bound is dependent on ray direction\n	var uz: f32 = abs(ray.direction.y);\n	var kr: f32 = uz + K * sqrt(1.0f - (uz * uz));\n\n    for (var i : i32 = 0; i<MAX_ITERS; i++)\n    {\n        // TODO: find a way to re-enable this optimisation because WebGPU has over strict uniformity analysis\n        // if (t < aabbTest.tFar)\n        // {\n        //     // passed the AABB and didn't hit anything\n        //     // stop raymarching\n        //     break;\n        // }\n\n        p = ray.origin + ray.direction * t;\n\n        dist = terrainSdf(p);\n\n        if (dist < 0.0f && !result.hit)\n        {\n            result.hit = true;\n            result.t = t;\n            result.hitPoint = p;\n\n            // break;   // stupid webgpu uniformity analysis issue. TODO: find a way to optimise here\n        }\n\n        if (dist >= MAX_DIST)\n        {\n            // break;   // stupid webgpu uniformity analysis issue. TODO: find a way to optimise here\n        }\n\n        t += max(dist / kr, MIN_DIST);\n    }\n\n    return result;\n}\n\n/* ============================================\n * ================= Shading ==================\n * ============================================\n*/\n\nfn computeNormal(p: vec3<f32>, eps: vec2<f32>) -> vec3<f32>\n{\n    var e: vec3<f32> = vec3(eps.x, 0.0, eps.y);\n    return normalize(vec3(getTerrainElevation(p.xz + e.xy) - getTerrainElevation(p.xz - e.xy),\n                            getTerrainElevation(p.xz + e.yz) - getTerrainElevation(p.xz - e.yz),\n                            length(eps)\n    ));\n}\n\nfn getTerrainColour(p: vec3<f32>) -> vec4<f32>\n{\n    // TODO: texture size should probably be higher when we get it from the CPU\n    var n: vec3<f32> = computeNormal(p, vec2(EPSILON));//(terrain.upperRight - terrain.lowerLeft) / vec2<f32>(terrain.textureSize));\n\n	// Terrain sides and bottom\n	if (abs(sdfBox2D(p.xz, terrain.lowerLeft, terrain.upperRight)) < EPSILON\n        || abs(p.y - heightRange.x + 0.1f * (heightRange.y - heightRange.x)) < EPSILON)\n    {\n        return vec4(0.3f, 0.29f, 0.31f, 1.0f);\n    }\n	\n    var shadingMode: i32 = 0;       // hardcoded\n\n	// Terrain interior\n	if (shadingMode == 0)   // normals\n	{\n        // TODO: find a way to optimise this non-uniformity nonsense\n		// var n: vec3<f32> = computeNormal(p, (terrain.upperRight - terrain.lowerLeft) / vec2<f32>(terrain.textureSize));\n		return vec4(0.2 * (vec3(3.0) + 2.0 * n.xyz), 1.0);\n	}\n	else if (shadingMode == 1)  // lambertian\n	{\n		var lightDir: vec3<f32> = normalize(vec3(0,0,0) - lightPos); // terrain located at world 0,0,0\n        var ambientTerm: f32 = 0.2;\n        var lambertianTerm: vec3<f32> = vec3(max(dot(n, lightDir), 0.0f) + ambientTerm);\n        \n        var col: vec3<f32> = vec3(1,1,1);\n		return vec4(lambertianTerm * col, 1.0f);\n	}\n	else\n    {\n		return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n\n@fragment\nfn frag_main(@location(0) fs_UV : vec2<f32>) -> @location(0) vec4<f32>\n{\n    var ray : Ray = rayCast(fs_UV);\n    var raymarchResult : RaymarchResult = raymarchTerrain(ray);\n    var outColor : vec4<f32> = vec4(0,0,0.2,1);\n\n    var terrainColor: vec4<f32> = getTerrainColour(raymarchResult.hitPoint);\n\n    if (raymarchResult.hit)\n    {\n        outColor = terrainColor;\n        // TODO: find a way to optimise this WebGPU non-uniformity nonsense\n        // outColor = getTerrainColour(raymarchResult.hitPoint);\n    }\n\n    // outColor = vec4((uniforms.right), 1);\n\n    return outColor;\n}",b),X=m.createSampler({magFilter:"linear",minFilter:"linear"});m.createTexture({size:[t.width,t.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});let j=m.createBuffer({size:400,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),q=m.createBuffer({size:280,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),Y=await fetch(_+u.heightfield+".png"),z=await createImageBitmap(await Y.blob()),[k,W]=[z.width,z.height];E=[0,1].map(e=>createTextureFromImage(m,z,!1,!1,"hf_".concat(u.heightfield,"_").concat(e))),m.queue.copyExternalImageToTexture({source:z},{texture:E[M]},[k,W]),D.push(createTextureFromImage(m,z,!1,!0,"hf_".concat(u.heightfield)));let K=I[1];Y=await fetch(_+K+".png"),z=await createImageBitmap(await Y.blob()),D.push(createTextureFromImage(m,z,!1,!0,"hf_".concat(K))),Y=await fetch(S+u.uplift+".png"),z=await createImageBitmap(await Y.blob());let Z=[0,1].map(e=>createTextureFromImage(m,z,!1,!1,"uplift_".concat(u.uplift,"_").concat(e)));m.queue.copyExternalImageToTexture({source:z},{texture:Z[M]},[z.width,z.height]),r=createTextureFromImage(m,z,!0,!0,"uplift_".concat(u.uplift)),G.push(r),K=A[1],Y=await fetch(S+K+".png"),z=await createImageBitmap(await Y.blob()),G.push(createTextureFromImage(m,z,!0,!0,"uplift_".concat(K))),Y=await fetch("assets/stream/streamInput.png"),z=await createImageBitmap(await Y.blob());let Q=[0,1].map(()=>m.createTexture({size:[k,W,1],format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}));m.queue.copyExternalImageToTexture({source:z},{texture:Q[M]},[k,W]),Y=await fetch(S+u.customBrush+".png"),i=createTextureFromImage(m,z=await createImageBitmap(await Y.blob()),!1,!0,"brush_".concat(u.customBrush)),V.push(i),K=U[1],Y=await fetch(S+K+".png"),z=await createImageBitmap(await Y.blob()),V.push(createTextureFromImage(m,z,!1,!0,"brush_".concat(K))),K=U[2],Y=await fetch(S+K+".png"),z=await createImageBitmap(await Y.blob()),V.push(createTextureFromImage(m,z,!1,!0,"brush_".concat(K)));let J=m.createComputePipeline({layout:"auto",compute:{module:m.createShaderModule({code:"struct SimulationParams {\n  nx         : i32,     // array dimension\n  ny         : i32,\n  lowerVertX : f32,     // lower and upper vertices of the box of the heightfield\n  lowerVertY : f32,\n  upperVertX : f32,\n  upperVertY : f32,\n  cellDiagX  : f32,     // cell diagonal\n  cellDiagY  : f32,\n}\n\nstruct CustomBrushParams {\n  brushPosX     : f32,\n  brushPosY     : f32,\n  brushScale    : f32,\n  brushStrength : f32,\n  width         : i32,  // brush texture size\n  height        : i32,\n  erase         : f32,  // temp boolean to erase terrain\n  useCustomBrush: f32,  // boolean\n  // TODO: rotation\n}\n\nstruct AABB {\n  lowerLeft   : vec2<f32>,\n  upperRight  : vec2<f32>,\n}\n\n// Uniforms\n@group(0) @binding(0) var<uniform> simParams : SimulationParams;\n\n@group(1) @binding(1) var inElevation : texture_2d<f32>;\n@group(1) @binding(2) var outElevation : texture_storage_2d<rgba8unorm, write>;\n@group(1) @binding(3) var inUplift : texture_2d<f32>;\n@group(1) @binding(4) var outUplift : texture_storage_2d<rgba8unorm, write>;\n@group(1) @binding(5) var inStream : texture_2d<f32>;\n@group(1) @binding(6) var outStream : texture_storage_2d<rgba8unorm, write>;\n\n@group(2) @binding(0) var<uniform> customBrushParams : CustomBrushParams;\n@group(2) @binding(1) var customBrush : texture_2d<f32>;\n\n// ----------- Global parameters -----------\n// 0: Stream power\n// 1: Stream power + Hillslope (Laplacian)\n// 2: Stream power + Hillslope (Laplacian) + Debris slope\nconst erosionMode : i32 = 2;\n\nconst uplift : f32 = 0.005;//0.01;\nconst k : f32 = 0.05;//0.0005;\nconst k_d : f32 = 10.0;\nconst k_h : f32 = 3.0;//2.0;\nconst p_sa : f32 = 1.0;//0.8;\nconst p_sl : f32 = 1.0;//2.0;\nconst dt : f32 = 2.0;//1.0;\n\n// const PAINT_STRENGTH : f32 = 10.0;\n// const PAINT_RADIUS : f32 = 10.0;\n\n// next 8 neighboring cells\nconst neighbors : array<vec2i, 8> = array<vec2i, 8>(\n  vec2i(0, 1), vec2i(1, 1), \n  vec2i(1, 0), vec2i(1, -1), \n  vec2i(0, -1), vec2i(-1, -1), \n  vec2i(-1, 0), vec2i(-1, 1)\n);\n\n// ----------- Utilities -----------\nfn ToIndex1D(i : i32, j : i32) -> i32 { return i + simParams.nx * j; }\n\nfn ToIndex1DFromCoord(p : vec2i) -> i32 { return p.x + simParams.nx * p.y; }\n\nfn Height(p : vec2i) -> f32 {\n    let color = textureLoad(inElevation, vec2u(p), 0);\n    return color.r;\n}\n\nfn UpliftAt(p : vec2i) -> f32 {\n  var PAINT_STRENGTH = customBrushParams.brushStrength;\n  var PAINT_RADIUS = customBrushParams.brushScale;\n\n    var pf = vec2f(p);\n    var color = textureLoad(inUplift, vec2u(p), 0);\n    if (customBrushParams.brushPosX != -1 && customBrushParams.brushPosY != -1) {\n      if (customBrushParams.useCustomBrush == 1) {\n        if (DrawBrush(p)) {\n          color.r += textureLoad(customBrush, vec2u(p), 0).r * customBrushParams.brushStrength;\n        }\n      }\n      else {\n        var dist = distance(vec2f(customBrushParams.brushPosX, customBrushParams.brushPosY), pf);\n        if (dist <= PAINT_RADIUS) {\n          var factor = 1.0 - dist * dist / (PAINT_RADIUS * PAINT_RADIUS);\n          if (customBrushParams.erase == 1) {\n            color.r -= PAINT_STRENGTH * factor * factor * factor;\n          }\n          else {\n            color.r += PAINT_STRENGTH * factor * factor * factor;\n          }\n        }\n      }\n    }\n    textureStore(outUplift, p, vec4f(vec3f(color.r), 1.f));\n    return color.r; // also greyscale?\n}\n\nfn StreamAt(p : vec2i) -> f32 {\n    let color = textureLoad(inStream, vec2u(p), 0);\n    return color.r; // also greyscale?\n}\n\nfn ArrayPoint(p : vec2i) -> vec2f {\n  let lowerVert = vec2f(simParams.lowerVertX, simParams.lowerVertY);\n  let cellDiag = vec2f(simParams.cellDiagX, simParams.cellDiagY);\n  return lowerVert + vec2f(p) * cellDiag;\n}\n\nfn Point3D(p : vec2i) -> vec3f {\n  return vec3f(ArrayPoint(p), Height(p));\n}\n\nfn Slope(p : vec2i, q : vec2i) -> f32 {\n  if (p.x < 0 || p.x >= simParams.nx || p.y < 0 || p.y >= simParams.ny) { return 0.0; }\n  if (q.x < 0 || q.x >= simParams.nx || q.y < 0 || q.y >= simParams.ny) { return 0.0; }\n  if (p.x == q.x && p.y == q.y) { return 0.0; }\n\n  var d = length(ArrayPoint(q) - ArrayPoint(p));\n  return (Height(q) - Height(p)) / d;\n}\n\nfn GetFlowSteepest(p : vec2i) -> vec2i {\n  var d = vec2i();\n  var maxSlope = 0.0;\n  for (var i = 0; i < 8; i++) {\n      var ss = Slope(p + neighbors[i], p);\n      if (ss > maxSlope) {\n        maxSlope = ss;\n        d = neighbors[i];\n      }\n  }\n  return d;\n}\n\nfn Stream(p : vec2i) -> f32 {\n  if (p.x < 0 || p.x >= simParams.nx || p.y < 0 || p.y >= simParams.ny) { return 0.0; }\n  \n  return StreamAt(p);\n}\n\nfn WaterSteepest(p : vec2i) -> f32 {\n  var water = 0.0;\n  for (var i = 0; i < 8; i++) {\n      var q = p + neighbors[i];\n      var fd = GetFlowSteepest(q);\n      if ((q + fd).x == p.x && (q + fd).y == p.y) {\n        water += Stream(q);\n      }\n  }\n  return water;\n}\n\nfn Laplacian(p : vec2i) -> f32 {\n  var laplacian = 0.0;\n  var i : i32 = p.x;\n  var j : i32 = p.y;\n\n  var sqrCellDiagX = simParams.cellDiagX * simParams.cellDiagX;\n  var sqrCellDiagY = simParams.cellDiagY * simParams.cellDiagY;\n\n  if (i == 0) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i+1, j)) + Height(vec2i(i+2, j))) / sqrCellDiagX;\n  }\n  else if (i == simParams.nx - 1) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i-1, j)) + Height(vec2i(i-2, j))) / sqrCellDiagX;\n  }\n  else {\n    laplacian += (Height(vec2i(i+1, j)) - 2.0 * Height(vec2i(i, j)) + Height(vec2i(i-1, j))) / sqrCellDiagX;\n  }\n  \n  if (j == 0) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i, j+1)) + Height(vec2i(i, j+2))) / sqrCellDiagY;\n  }\n  else if (j == simParams.ny - 1) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i, j-1)) + Height(vec2i(i, j-2))) / sqrCellDiagY;\n  }\n  else {\n    laplacian += (Height(vec2i(i, j+1)) - 2.0 * Height(vec2i(i, j)) + Height(vec2i(i, j-1))) / sqrCellDiagY;\n  }\n\n  return laplacian;\n}\n\nfn Read(p : vec2i) -> vec4f {\n  if (p.x < 0 || p.x >= simParams.nx || p.y < 0 || p.y >= simParams.ny) {\n    return vec4f();\n  }\n\n  var ret = vec4f();\n  ret.x = Height(p);        // Bedrock elevation\n  ret.y = StreamAt(p);      // Stream area\n  ret.z = UpliftAt(p);      // Uplift factor\n  return ret;\n}\n\nfn Write(p : vec2i, data : vec4f) {\n  textureStore(outElevation, p, vec4f(data.x));\n  textureStore(outStream, p, vec4f(data.y));\n}\n\n// Local Editing\nfn GetBrushAABB() -> AABB {\n  var center = vec2f(customBrushParams.brushPosX, customBrushParams.brushPosY);\n  var halfWidth = f32(customBrushParams.width / 2);\n  var halfHeight = f32(customBrushParams.height / 2);\n  var scale = customBrushParams.brushScale;\n\n  var lowerLeft = vec2f(center.x - halfWidth * scale, center.y - halfHeight * scale);\n  var upperRight = vec2f(center.x + halfWidth * scale, center.y + halfHeight * scale);\n  return AABB(lowerLeft, upperRight);\n}\n\nfn ArrayPointBrush(p : vec2i) -> vec2f {\n  var aabb = GetBrushAABB();\n  let cellDiag = vec2f(simParams.cellDiagX, simParams.cellDiagY);\n  return aabb.lowerLeft + vec2f(p) * cellDiag;\n}\n\nfn DrawBrush(p : vec2i) -> bool {\n  var aabb = GetBrushAABB();\n  return (aabb.lowerLeft.x < ArrayPointBrush(p).x && ArrayPointBrush(p).x < aabb.upperRight.x) &&\n         (aabb.lowerLeft.y < ArrayPointBrush(p).y && ArrayPointBrush(p).y < aabb.upperRight.y);\n}\n\n@compute @workgroup_size(64)\nfn main(\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let idX = i32(GlobalInvocationID.x);\n  let idY = i32(GlobalInvocationID.y);\n  if (idX < 0 || idY < 0) { return; }\n  if (idX >= simParams.nx || idY >= simParams.ny) { return; }\n\n  var id : i32 = ToIndex1D(idX, idY);\n  var p : vec2i = vec2i(idX, idY);\n  var data : vec4f = Read(p);\n  var cellDiag = vec2f(simParams.cellDiagX, simParams.cellDiagY);\n\n  // Border nodes are fixed to zero (elevation and drainage)\n  if (p.x == 0 || p.x == simParams.nx - 1 ||\n      p.y == 0 || p.y == simParams.ny - 1) {\n    data.x = 0.0;\n    data.y = 1.0 * length(cellDiag);\n    Write(p, data);\n    return;\n  }\n\n  // Flows accumulation at p\n  var waterIncr = WaterSteepest(p);\n\n  data.y = 1.0 * length(cellDiag);\n  data.y += waterIncr;\n\n  // Erosion at p (relative to steepest)\n  var d = GetFlowSteepest(p);\n  var receiver = Read(p + d);\n  var pSlope = abs(Slope(p + d, p));\n\n  var erosion = k * pow(data.y, p_sa) * pow(pSlope, p_sl);\n\n  var newHeight = data.x;\n  if (erosionMode == 0) {           // Stream power\n    newHeight -= dt * (erosion);\n  }\n  else if (erosionMode == 1) {      // Stream power + Hillslope erosion (Laplacian)\n    newHeight -= dt * (erosion - k_h * Laplacian(p));\n  }\n  else if (erosionMode == 2) {      // Stream power + Hillslope erosion (Laplacian) + Debris flow\n    newHeight -= dt * (erosion - k_h * Laplacian(p) - k_d * pSlope);\n  }\n\n  newHeight = max(newHeight, receiver.x);\n  newHeight += dt * uplift * data.z;\n\n  data.x = newHeight;\n  Write(p, data);\n}"}),entryPoint:"main"}}),$=m.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),ee=m.createBindGroup({label:"simulation constants",layout:J.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:$}}]}),et={label:"compute bind group descriptor 0",layout:J.getBindGroupLayout(1),entries:[{binding:1,resource:E[0].createView()},{binding:2,resource:E[1].createView()},{binding:3,resource:Z[0].createView()},{binding:4,resource:Z[1].createView()},{binding:5,resource:Q[0].createView()},{binding:6,resource:Q[1].createView()}]},en={label:"compute bind group descriptor 1",layout:J.getBindGroupLayout(1),entries:[{binding:1,resource:E[1].createView()},{binding:2,resource:E[0].createView()},{binding:3,resource:Z[1].createView()},{binding:4,resource:Z[0].createView()},{binding:5,resource:Q[1].createView()},{binding:6,resource:Q[0].createView()}]},er=m.createBindGroup(et),ei=m.createBindGroup(en),ea=[er,ei],eo=m.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),es={label:"brush bind group descriptor",layout:J.getBindGroupLayout(2),entries:[{binding:0,resource:{buffer:eo}},{binding:1,resource:i.createView()}]},eu=m.createBindGroup(es);o.createTerrainBindGroup(O,j,0,X,E[M],q),a.createBindGroup(F,j,256,X,E[M]);let ec=new T;requestAnimationFrame(function frame(){if(!n.active)return;if(C){var e,t;let n,r,i,a,o=B.resolution[0]/window.devicePixelRatio,s=B.resolution[1]/window.devicePixelRatio,u=function(e,t,n,r,i){let a=2*r/t-1,o=2*i/n-1;console.log("ux:",a),console.log("uy:",o);let s=141.3716694115407/180,u=p.R3.mulScalar(e.up,Math.tan(.5*s)),c=p.R3.mulScalar(e.right,Math.tan(.5*s)*(t/n)),l=p.R3.add(p.R3.add(e.getPosition(),e.forward),p.R3.mulScalar(c,a));p.R3.add(l,p.R3.mulScalar(u,o),l);let f=p.R3.sub(l,e.getPosition());return p.R3.normalize(f)}(B,o,s,L,N),c=p.vh.create(B.getPosition()[0],B.getPosition()[1],B.getPosition()[2],1),l=p.vh.create(u[0],u[1],u[2],0);p._E.multiply(B.projectionMatrix,B.viewMatrix()),c=p.R3.fromValues(c[0],c[1],c[2]),l=p.R3.fromValues(l[0],l[1],l[2]);let[f,h]=(e=c,t=l,n=p.vh.create(0,1,0,0),r=p.vh.create(0,0,0,0),i=p.R3.dot(n,p.R3.sub(r,e))/p.R3.dot(n,t),a=p.R3.add(e,p.R3.mulScalar(t,i)),i<0||a[0]<-5||a[0]>5||a[2]<-5||a[2]>5?[!1,null]:[!0,a]),d=-1,g=-1;if(f){console.log("Ray hit!");let e=p.R3.sub(p.R3.create(h[0],h[1],h[2]),p.R3.create(-5,0,-5)),t=p.R3.sub(p.R3.create(5,0,5),p.R3.create(-5,0,-5)),n=p.R3.div(e,t);d=Math.floor(n[0]*k),g=Math.floor(n[2]*W),console.log("px: ",d),console.log("py: ",g)}else console.log("alas....");H[0]=d,H[1]=g}else B.update(),H[0]=-1,H[1]=-1;let s=m.createCommandEncoder();(c||d)&&(d&&(s.copyTextureToTexture({texture:D[l[u.heightfield]]},{texture:E[M]},{width:k,height:W}),d=!1),et.entries[0].resource=E[0].createView(),et.entries[1].resource=E[1].createView(),et.entries[2].resource=r.createView(),en.entries[0].resource=E[1].createView(),en.entries[1].resource=E[0].createView(),en.entries[2].resource=r.createView(),er=m.createBindGroup(et),ei=m.createBindGroup(en),ea=[er,ei],es.entries[1].resource=i.createView(),eu=m.createBindGroup(es),c=!1);{let e=s.beginComputePass();e.setPipeline(J),m.queue.writeBuffer($,0,new Float32Array([ec.nx,ec.ny,ec.lowerVertX,ec.lowerVertY,ec.upperVertX,ec.upperVertY,ec.cellDiagX,ec.cellDiagY]));let t=0,n=0;u.eraseTerrain&&(t=1),u.useCustomBrush&&(n=1),m.queue.writeBuffer(eo,0,new Float32Array([H[0],H[1],u.brushScale,u.brushStrength,i.height,i.width,t,n])),e.setBindGroup(0,ee),e.setBindGroup(1,ea[M]),e.setBindGroup(2,eu),e.dispatchWorkgroups(Math.ceil(k),Math.ceil(W)),e.end(),M=(M+1)%2}{let e=s.beginRenderPass({colorAttachments:[{view:v.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});e.setPipeline(O),writeMVPUniformBuffer(m,j,0,o.getModelMatrix(),B,!0),function(e,t,n){e.queue.writeBuffer(t,0,new Float32Array([n.nx,n.ny,n.lowerVertX,n.lowerVertY,n.upperVertX,n.upperVertY]))}(m,q,ec),e.setBindGroup(0,o.bindGroup),e.setIndexBuffer(o.indexBuffer,"uint32"),e.setVertexBuffer(0,o.posBuffer),e.setVertexBuffer(1,o.normalBuffer),e.setVertexBuffer(2,o.uvBuffer),e.drawIndexed(o.count),e.end()}{let e=s.beginRenderPass({colorAttachments:[{view:v.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"load",storeOp:"store"}]});e.setPipeline(F),writeMVPUniformBuffer(m,j,256,a.getModelMatrix(),B,!0),e.setBindGroup(0,a.bindGroup),e.setIndexBuffer(a.indexBuffer,"uint32"),e.setVertexBuffer(0,a.posBuffer),e.setVertexBuffer(1,a.normalBuffer),e.setVertexBuffer(2,a.uvBuffer),e.drawIndexed(a.count),e.end()}m.queue.submit([s.finish()]),requestAnimationFrame(frame)})};var pages=()=>makeSample({name:"Terrain X",description:"Interactive terrain authoring and erosion simulation on WebGPU",gui:!0,stats:!0,init,filename:"src/sample/terrainX/main.ts"})},4131:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__ZTWP5"}}},function(e){e.O(0,[746,150,774,888,179],function(){return e(e.s=8312)}),_N_E=e.O()}]);