(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[405],{8312:function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return r(3408)}])},3408:function(e,n,r){"use strict";r.r(n),r.d(n,{default:function(){return pages}});var t=r(5893),i=r(9008),a=r.n(i),o=r(7294),l=r(4131),s=r.n(l);let SampleLayout=e=>{let n=(0,o.useRef)(null),i=(0,o.useRef)(null),l=(0,o.useMemo)(()=>{if(e.gui){let e=r(4376);return new e.GUI({autoPlace:!1})}},[]),c=(0,o.useRef)(null),u=(0,o.useMemo)(()=>{if(e.stats){let e=r(2792);return new e}},[]),[p,g]=(0,o.useState)(null);return(0,o.useEffect)(()=>{if(l&&i.current)for(i.current.appendChild(l.domElement);l.__controllers.length>0;)l.__controllers[0].remove();u&&c.current&&(u.dom.style.position="absolute",u.showPanel(1),c.current.appendChild(u.dom));let r={active:!0};try{let t=n.current;if(!t)throw Error("The canvas is not available");let i=e.init({canvas:t,pageState:r,gui:l,stats:u});i instanceof Promise&&i.catch(e=>{console.error(e),g(e)})}catch(e){console.error(e),g(e)}return()=>{r.active=!1}},[]),(0,t.jsxs)("main",{children:[(0,t.jsxs)(a(),{children:[(0,t.jsx)("title",{children:"Terrain X"}),(0,t.jsx)("meta",{name:"description",content:e.description}),(0,t.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,t.jsxs)("div",{children:[(0,t.jsx)("h1",{children:e.name}),(0,t.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://github.com/".concat("GPU-Gang/WebGPU-Erosion-Simulation","/tree/main/").concat(e.filename),children:"See it on Github!"}),(0,t.jsx)("p",{children:e.description}),p?(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("p",{children:"Something went wrong. Do your browser and device support WebGPU?"}),(0,t.jsx)("p",{children:"".concat(p)})]}):null]}),(0,t.jsxs)("div",{className:s().canvasContainer,children:[(0,t.jsx)("div",{style:{position:"absolute",left:10},ref:c}),(0,t.jsx)("div",{style:{position:"absolute",right:10},ref:i}),(0,t.jsx)("canvas",{ref:n})]})]})},makeSample=e=>(0,t.jsx)(SampleLayout,{...e});var c="@group(0) @binding(0) var mySampler : sampler;\n@group(0) @binding(1) var myTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fragUV : vec2<f32>,\n}\n\n@vertex\nfn vert_main(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {\n  const pos = array(\n    vec2( 1.0,  1.0),\n    vec2( 1.0, -1.0),\n    vec2(-1.0, -1.0),\n    vec2( 1.0,  1.0),\n    vec2(-1.0, -1.0),\n    vec2(-1.0,  1.0),\n  );\n\n  const uv = array(\n    vec2(1.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(0.0, 0.0),\n  );\n\n  var output : VertexOutput;\n  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);\n  output.fragUV = uv[VertexIndex];\n  return output;\n}\n\n@fragment\nfn frag_main(@location(0) fragUV : vec2<f32>) -> @location(0) vec4<f32> {\n  return textureSample(myTexture, mySampler, fragUV);\n}\n";let u=0,init=async e=>{let{canvas:n,pageState:r,gui:t}=e,i=await navigator.gpu.requestAdapter(),a=await i.requestDevice();if(!r.active)return;let o=n.getContext("webgpu"),l=window.devicePixelRatio;n.width=n.clientWidth*l,n.height=n.clientHeight*l;let s=navigator.gpu.getPreferredCanvasFormat();o.configure({device:a,format:s,alphaMode:"premultiplied"});let p=a.createRenderPipeline({layout:"auto",vertex:{module:a.createShaderModule({code:c}),entryPoint:"vert_main"},fragment:{module:a.createShaderModule({code:c}),entryPoint:"frag_main",targets:[{format:s}]},primitive:{topology:"triangle-list"}}),g=a.createSampler({magFilter:"linear",minFilter:"linear"}),m=a.createBuffer({size:48,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0});new Float32Array(m.getMappedRange()).set([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),m.unmap();let d=await fetch("assets/heightfields/hfTest1.png"),f=await createImageBitmap(await d.blob()),[v,x]=[f.width,f.height],h=[0,1].map(()=>a.createTexture({size:[v,x,1],format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}));a.queue.copyExternalImageToTexture({source:f},{texture:h[u]},[v,x]),d=await fetch("assets/uplifts/lambda.png"),f=await createImageBitmap(await d.blob());let w=a.createTexture({size:[v,x,1],format:"r8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});a.queue.copyExternalImageToTexture({source:f},{texture:w},[f.width,f.height]),d=await fetch("assets/stream/streamInput.png"),f=await createImageBitmap(await d.blob());let b=[0,1].map(()=>a.createTexture({size:[v,x,1],format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}));a.queue.copyExternalImageToTexture({source:f},{texture:b[u]},[v,x]);let y=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:"struct SimulationParams {\n  nx         : i32,    // array dimension\n  ny         : i32,\n  lowerVertX : f32,  // lower and upper vertices of the box of the heightfield\n  lowerVertY : f32,\n  upperVertX : f32,\n  upperVertY : f32,\n  cellDiagX  : f32,  // cell diagonal\n  cellDiagY  : f32,\n}\n\n// Uniforms\n@group(0) @binding(0) var<uniform> simParams : SimulationParams;\n\n@group(1) @binding(1) var inElevation : texture_2d<f32>;\n@group(1) @binding(2) var outElevation : texture_storage_2d<rgba8unorm, write>;\n@group(1) @binding(3) var inUplift : texture_2d<f32>;\n@group(1) @binding(4) var inStream : texture_2d<f32>;\n@group(1) @binding(5) var outStream : texture_storage_2d<rgba8unorm, write>;\n\n// ----------- Global parameters -----------\n// 0: Stream power\n// 1: Stream power + Hillslope (Laplacian)\n// 2: Stream power + Hillslope (Laplacian) + Debris slope\nconst erosionMode : i32 = 2;\n\nconst uplift : f32 = 0.005;//0.01;\nconst k : f32 = 0.05;//0.0005;\nconst k_d : f32 = 10.0;\nconst k_h : f32 = 3.0;//2.0;\nconst p_sa : f32 = 1.0;//0.8;\nconst p_sl : f32 = 1.0;//2.0;\nconst dt : f32 = 7.0;//1.0;\n\n// next 8 neighboring cells\nconst neighbors : array<vec2i, 8> = array<vec2i, 8>(\n  vec2i(0, 1), vec2i(1, 1), \n  vec2i(1, 0), vec2i(1, -1), \n  vec2i(0, -1), vec2i(-1, -1), \n  vec2i(-1, 0), vec2i(-1, 1)\n);\n\n// ----------- Utilities -----------\nfn ToIndex1D(i : i32, j : i32) -> i32 { return i + simParams.nx * j; }\n\nfn ToIndex1DFromCoord(p : vec2i) -> i32 { return p.x + simParams.nx * p.y; }\n\nfn Height(p : vec2i) -> f32 {\n    let color = textureLoad(inElevation, vec2u(p), 0);\n    return color.r;\n}\n\nfn UpliftAt(p : vec2i) -> f32 {\n    let color = textureLoad(inUplift, vec2u(p), 0);\n    return color.r; // also greyscale?\n}\n\nfn StreamAt(p : vec2i) -> f32 {\n    let color = textureLoad(inStream, vec2u(p), 0);\n    return color.r; // also greyscale?\n}\n\nfn ArrayPoint(p : vec2i) -> vec2f {\n  let lowerVert = vec2f(simParams.lowerVertX, simParams.lowerVertY);\n  let cellDiag = vec2f(simParams.cellDiagX, simParams.cellDiagY);\n  return lowerVert + vec2f(p) * cellDiag;\n}\n\nfn Point3D(p : vec2i) -> vec3f {\n  return vec3f(ArrayPoint(p), Height(p));\n}\n\nfn Slope(p : vec2i, q : vec2i) -> f32 {\n  if (p.x < 0 || p.x >= simParams.nx || p.y < 0 || p.y >= simParams.ny) { return 0.0; }\n  if (q.x < 0 || q.x >= simParams.nx || q.y < 0 || q.y >= simParams.ny) { return 0.0; }\n  if (p.x == q.x && p.y == q.y) { return 0.0; }\n\n  var d = length(ArrayPoint(q) - ArrayPoint(p));\n  return (Height(q) - Height(p)) / d;\n}\n\nfn GetFlowSteepest(p : vec2i) -> vec2i {\n  var d = vec2i();\n  var maxSlope = 0.0;\n  for (var i = 0; i < 8; i++) {\n      var ss = Slope(p + neighbors[i], p);\n      if (ss > maxSlope) {\n        maxSlope = ss;\n        d = neighbors[i];\n      }\n  }\n  return d;\n}\n\nfn Stream(p : vec2i) -> f32 {\n  if (p.x < 0 || p.x >= simParams.nx || p.y < 0 || p.y >= simParams.ny) { return 0.0; }\n  \n  return StreamAt(p);\n}\n\nfn WaterSteepest(p : vec2i) -> f32 {\n  var water = 0.0;\n  for (var i = 0; i < 8; i++) {\n      var q = p + neighbors[i];\n      var fd = GetFlowSteepest(q);\n      if ((q + fd).x == p.x && (q + fd).y == p.y) {\n        water += Stream(q);\n      }\n  }\n  return water;\n}\n\nfn Laplacian(p : vec2i) -> f32 {\n  var laplacian = 0.0;\n  var i : i32 = p.x;\n  var j : i32 = p.y;\n\n  var sqrCellDiagX = simParams.cellDiagX * simParams.cellDiagX;\n  var sqrCellDiagY = simParams.cellDiagY * simParams.cellDiagY;\n\n  if (i == 0) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i+1, j)) + Height(vec2i(i+2, j))) / sqrCellDiagX;\n  }\n  else if (i == simParams.nx - 1) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i-1, j)) + Height(vec2i(i-2, j))) / sqrCellDiagX;\n  }\n  else {\n    laplacian += (Height(vec2i(i+1, j)) - 2.0 * Height(vec2i(i, j)) + Height(vec2i(i-1, j))) / sqrCellDiagX;\n  }\n  \n  if (j == 0) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i, j+1)) + Height(vec2i(i, j+2))) / sqrCellDiagY;\n  }\n  else if (i == simParams.nx - 1) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i, j-1)) + Height(vec2i(i, j-2))) / sqrCellDiagY;\n  }\n  else {\n    laplacian += (Height(vec2i(i, j+1)) - 2.0 * Height(vec2i(i, j)) + Height(vec2i(i, j-1))) / sqrCellDiagY;\n  }\n\n  return laplacian;\n}\n\nfn Read(p : vec2i) -> vec4f {\n  if (p.x < 0 || p.x >= simParams.nx || p.y < 0 || p.y >= simParams.ny) {\n    return vec4f();\n  }\n\n  var ret = vec4f();\n  ret.x = Height(p);        // Bedrock elevation\n  ret.y = StreamAt(p);      // Stream area\n  ret.z = UpliftAt(p);      // Uplift factor\n  return ret;\n}\n\nfn Write(p : vec2i, data : vec4f) {\n  textureStore(outElevation, p, vec4f(data.x));\n  textureStore(outStream, p, vec4f(data.y));\n}\n\n\n@compute @workgroup_size(64)\nfn main(\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let idX = i32(GlobalInvocationID.x);\n  let idY = i32(GlobalInvocationID.y);\n  if (idX < 0 || idY < 0) { return; }\n  if (idX >= simParams.nx || idY >= simParams.ny) { return; }\n\n  var id : i32 = ToIndex1D(idX, idY);\n  var p : vec2i = vec2i(idX, idY);\n  var data : vec4f = Read(p);\n  var cellDiag = vec2f(simParams.cellDiagX, simParams.cellDiagY);\n\n  // Border nodes are fixed to zero (elevation and drainage)\n  if (p.x == 0 || p.x == simParams.nx - 1 ||\n      p.y == 0 || p.y == simParams.ny - 1) {\n    data.x = 0.0;\n    data.y = 1.0 * length(cellDiag);\n    Write(p, data);\n    return;\n  }\n\n  // Flows accumulation at p\n  var waterIncr = WaterSteepest(p);\n\n  data.y = 1.0 * length(cellDiag);\n  data.y += waterIncr;\n\n  // Erosion at p (relative to steepest)\n  var d = GetFlowSteepest(p);\n  var receiver = Read(p + d);\n  var pSlope = abs(Slope(p + d, p));\n\n  var erosion = k * pow(data.y, p_sa) * pow(pSlope, p_sl);\n\n  var newHeight = data.x;\n  if (erosionMode == 0) {           // Stream power\n    newHeight -= dt * (erosion);\n  }\n  else if (erosionMode == 1) {      // Stream power + Hillslope erosion (Laplacian)\n    newHeight -= dt * (erosion - k_h * Laplacian(p));\n  }\n  else if (erosionMode == 2) {      // Stream power + Hillslope erosion (Laplacian) + Debris flow\n    newHeight -= dt * (erosion - k_h * Laplacian(p) - k_d * pSlope);\n  }\n\n  newHeight = max(newHeight, receiver.x);\n  newHeight += dt * uplift * data.z;\n\n  data.x = newHeight;\n  Write(p, data);\n}"}),entryPoint:"main"}}),P=a.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),_=a.createBindGroup({label:"simulation constants",layout:y.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:P}}]}),S=a.createBindGroup({label:"compute bind group 0",layout:y.getBindGroupLayout(1),entries:[{binding:1,resource:h[0].createView()},{binding:2,resource:h[1].createView()},{binding:3,resource:w.createView()},{binding:4,resource:b[0].createView()},{binding:5,resource:b[1].createView()}]}),T=a.createBindGroup({label:"compute bind group 1",layout:y.getBindGroupLayout(1),entries:[{binding:1,resource:h[1].createView()},{binding:2,resource:h[0].createView()},{binding:3,resource:w.createView()},{binding:4,resource:b[1].createView()},{binding:5,resource:b[0].createView()}]}),D=[S,T],U=a.createBindGroup({layout:p.getBindGroupLayout(0),entries:[{binding:0,resource:g},{binding:1,resource:h[u].createView()}]}),G={nx:256,ny:256,lowerVertX:-15e4,lowerVertY:-15e4,upperVertX:15e4,upperVertY:15e4,cellDiagX:1176.47,cellDiagY:1176.47};a.queue.writeBuffer(P,0,new Float32Array([G.nx,G.ny,G.lowerVertX,G.lowerVertY,G.upperVertX,G.upperVertY,G.cellDiagX,G.cellDiagY])),requestAnimationFrame(function frame(){if(!r.active)return;let e=a.createCommandEncoder();{let n=e.beginComputePass();n.setPipeline(y),n.setBindGroup(0,_),n.setBindGroup(1,D[u]),n.dispatchWorkgroups(Math.ceil(v),Math.ceil(x)),n.end(),u=(u+1)%2}{let n=e.beginRenderPass({colorAttachments:[{view:o.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});n.setPipeline(p),n.setBindGroup(0,U),n.draw(6),n.end()}a.queue.submit([e.finish()]),requestAnimationFrame(frame)})};var pages=()=>makeSample({name:"Terrain X",description:"Interactive terrain authoring and erosion simulation on WebGPU",gui:!0,stats:!0,init,filename:"src/sample/terrainX/main.ts"})},4131:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__ZTWP5"}}},function(e){e.O(0,[784,774,888,179],function(){return e(e.s=8312)}),_N_E=e.O()}]);