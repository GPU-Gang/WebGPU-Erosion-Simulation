(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[405],{8312:function(e,t,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/",function(){return r(3695)}])},3695:function(e,t,r){"use strict";let i,n;r.r(t),r.d(t,{default:function(){return pages}});var a=r(6416),o=r(5893),s=r(9008),u=r.n(s),l=r(7294),c=r(4131),p=r.n(c);let SampleLayout=e=>{let t=(0,l.useRef)(null),i=(0,l.useRef)(null),n=(0,l.useMemo)(()=>{if(e.gui){let e=r(4376);return new e.GUI({autoPlace:!1})}},[]),a=(0,l.useRef)(null),s=(0,l.useMemo)(()=>{if(e.stats){let e=r(2792);return new e}},[]),[c,f]=(0,l.useState)(null);return(0,l.useEffect)(()=>{if(n&&i.current)for(i.current.appendChild(n.domElement);n.__controllers.length>0;)n.__controllers[0].remove();s&&a.current&&(s.dom.style.position="absolute",s.showPanel(1),a.current.appendChild(s.dom));let r={active:!0};try{let i=t.current;if(!i)throw Error("The canvas is not available");let a=e.init({canvas:i,pageState:r,gui:n,stats:s});a instanceof Promise&&a.catch(e=>{console.error(e),f(e)})}catch(e){console.error(e),f(e)}return()=>{r.active=!1}},[]),(0,o.jsxs)("main",{children:[(0,o.jsxs)(u(),{children:[(0,o.jsx)("title",{children:"Terrain X"}),(0,o.jsx)("meta",{name:"description",content:e.description}),(0,o.jsx)("meta",{httpEquiv:"origin-trial",content:e.originTrial})]}),(0,o.jsxs)("div",{children:[(0,o.jsx)("h1",{children:e.name}),(0,o.jsx)("a",{target:"_blank",rel:"noreferrer",href:"https://github.com/".concat("GPU-Gang/WebGPU-Erosion-Simulation","/tree/main/").concat(e.filename),children:"See it on Github!"}),(0,o.jsx)("p",{children:e.description}),c?(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)("p",{children:"Something went wrong. Do your browser and device support WebGPU?"}),(0,o.jsx)("p",{children:"".concat(c)})]}):null]}),(0,o.jsxs)("div",{className:p().canvasContainer,children:[(0,o.jsx)("div",{style:{position:"absolute",left:10},ref:a}),(0,o.jsx)("div",{style:{position:"absolute",right:10},ref:i}),(0,o.jsx)("canvas",{ref:t})]})]})},makeSample=e=>(0,o.jsx)(SampleLayout,{...e});var f=r(4478),d=class{setAspectRatio(e){this.aspectRatio=e}updateProjectionMatrix(){a._E.perspective(this.fovy,this.aspectRatio,this.near,this.far,this.projectionMatrix)}setPosition(e){let t=a.R3.fromValues(e[0]-this.position[0],e[1]-this.position[1],e[2]-this.position[2]);this.controls.pan(t[0],t[1],t[2]),this.position=e}update(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:a.R3.create(0,0,0);this.controls.tick(),a.R3.add(this.position,this.direction,this.target);let t=a.R3.create();a.R3.subtract(this.controls.eye,e,t),a._E.lookAt(t,this.controls.center,this.controls.up,this.viewMatrix)}constructor(e,t){this.projectionMatrix=a._E.create(),this.viewMatrix=a._E.create(),this.fovy=45,this.aspectRatio=1,this.near=.1,this.far=1e3,this.position=a.R3.create(),this.direction=a.R3.create(),this.target=a.R3.create(),this.up=a.R3.create(),this.controls=f(document.getElementById("canvas"),{eye:e,center:t}),this.position=e}},h="struct Uniforms {\n  modelViewProjectionMatrix : mat4x4<f32>,\n}\n@group(0) @binding(0) var<uniform> uniforms : Uniforms;\n\n@group(0) @binding(1) var mySampler : sampler;\n@group(0) @binding(2) var myTexture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) Position : vec4<f32>,\n  @location(0) fs_UV : vec2<f32>,\n}\n\n@vertex\nfn vert_main(\n  @location(0) vs_pos: vec4<f32>,\n  @location(1) vs_nor: vec4<f32>,\n  @location(2) vs_uv: vec2<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = uniforms.modelViewProjectionMatrix * vs_pos;\n  output.fs_UV = vs_uv;\n  return output;\n}\n\n@fragment\nfn frag_main(@location(0) fs_UV : vec2<f32>) -> @location(0) vec4<f32> {\n  return textureSample(myTexture, mySampler, fs_UV);\n}",g=class{create(e){this.device=e}createIndexBuffer(){return this.idxBound||(this.idxBound=!0,this.indexBuffer=this.device.createBuffer({size:this.indices.byteLength,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),new Uint32Array(this.indexBuffer.getMappedRange()).set(this.indices),this.indexBuffer.unmap()),this.indexBuffer}createPosBuffer(){return this.posBound||(this.posBound=!0,this.posBuffer=this.device.createBuffer({size:this.positions.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.posBuffer.getMappedRange()).set(this.positions),this.posBuffer.unmap()),this.posBuffer}createNormalBuffer(){return this.norBound||(this.norBound=!0,this.normalBuffer=this.device.createBuffer({size:this.normals.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.normalBuffer.getMappedRange()).set(this.normals),this.normalBuffer.unmap()),this.normalBuffer}createUVBuffer(){return this.uvBound||(this.uvBound=!0,this.uvBuffer=this.device.createBuffer({size:this.uvs.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.uvBuffer.getMappedRange()).set(this.uvs),this.uvBuffer.unmap()),this.uvBuffer}elemCount(){return this.count}constructor(){this.count=0,this.idxBound=!1,this.posBound=!1,this.norBound=!1,this.uvBound=!1}};function degToRad(e){return .0174533*e}var m=class extends g{create(e){super.create(e),this.indices=new Uint32Array([0,1,2,0,2,3]),this.normals=new Float32Array([0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0]),this.positions=new Float32Array([-1,-1,0,1,1,-1,0,1,1,1,0,1,-1,1,0,1]),this.uvs=new Float32Array([0,1,1,1,1,0,0,0]),this.count=this.indices.length,this.createIndexBuffer(),this.createPosBuffer(),this.createNormalBuffer(),this.createUVBuffer(),console.log("Created quad")}createBindGroup(e,t,r,i,n){return this.bindGroupCreated||(this.bindGroupCreated=!0,this.bindGroup=this.device.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t,offset:r}},{binding:1,resource:i},{binding:2,resource:n.createView()}]})),this.bindGroup}getModelMatrix(){let e=a._E.identity();return a._E.rotateX(e,this.rotation[0],e),a._E.rotateY(e,this.rotation[1],e),a._E.rotateZ(e,this.rotation[2],e),a._E.scale(e,this.scale,e),a._E.translate(e,this.center,e),e}constructor(e=a.vh.create(0,0,0,0),t=a.R3.create(1,1,1),r=a.R3.create(0,0,0)){super(),this.bindGroupCreated=!1,this.center=a.vh.fromValues(e[0],e[1],e[2],1),this.scale=t,this.rotation=r,this.rotation[0]=degToRad(this.rotation[0]),this.rotation[1]=degToRad(this.rotation[1]),this.rotation[2]=degToRad(this.rotation[2])}};let v=0;function writeMVPUniformBuffer(e,t,r,i,n,o){let s=a._E.identity();a._E.multiply(n,i,s),a._E.multiply(o,s,s),e.queue.writeBuffer(t,r,new Float32Array([s[0],s[1],s[2],s[3],s[4],s[5],s[6],s[7],s[8],s[9],s[10],s[11],s[12],s[13],s[14],s[15],n[0],n[4],n[8],0,n[1],n[5],n[9],0]))}let init=async e=>{let{canvas:t,pageState:r,gui:o}=e,s=await navigator.gpu.requestAdapter(),u=await s.requestDevice();if(!r.active)return;let l=t.getContext("webgpu"),c=window.devicePixelRatio;t.width=t.clientWidth*c,t.height=t.clientHeight*c;let p=navigator.gpu.getPreferredCanvasFormat();l.configure({device:u,format:p,alphaMode:"premultiplied"}),(i=new m(a.vh.create(2.5,2.5,0,0),a.R3.create(.3,.3,1))).create(u),(n=new m(a.vh.create(0,0,0,0),a.R3.create(1,1,1),a.R3.create(0,180,0))).create(u);let f=new d(a.R3.create(0,0,-3),n.center);f.setAspectRatio(t.width/t.height),f.updateProjectionMatrix();let g=u.createRenderPipeline({layout:"auto",vertex:{module:u.createShaderModule({code:h}),entryPoint:"vert_main",buffers:[{arrayStride:16,attributes:[{shaderLocation:0,format:"float32x4",offset:0}]},{arrayStride:16,attributes:[{shaderLocation:1,format:"float32x4",offset:0}]},{arrayStride:8,attributes:[{shaderLocation:2,format:"float32x2",offset:0}]}]},fragment:{module:u.createShaderModule({code:h}),entryPoint:"frag_main",targets:[{format:p}]},primitive:{topology:"triangle-list",cullMode:"back"}}),x=u.createSampler({magFilter:"linear",minFilter:"linear"});u.createTexture({size:[t.width,t.height],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});let w=u.createBuffer({size:352,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),y=await fetch("assets/heightfields/hfTest1.png"),B=await createImageBitmap(await y.blob()),[b,P]=[B.width,B.height],_=[0,1].map(()=>u.createTexture({size:[b,P,1],mipLevelCount:1,format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}));u.queue.copyExternalImageToTexture({source:B},{texture:_[v]},[b,P]),y=await fetch("assets/uplifts/lambda.png"),B=await createImageBitmap(await y.blob());let U=u.createTexture({size:[b,P,1],format:"r8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});u.queue.copyExternalImageToTexture({source:B},{texture:U},[B.width,B.height]),y=await fetch("assets/stream/streamInput.png"),B=await createImageBitmap(await y.blob());let T=[0,1].map(()=>u.createTexture({size:[b,P,1],format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}));u.queue.copyExternalImageToTexture({source:B},{texture:T[v]},[b,P]);let E=u.createComputePipeline({layout:"auto",compute:{module:u.createShaderModule({code:"struct SimulationParams {\n  nx         : i32,    // array dimension\n  ny         : i32,\n  lowerVertX : f32,  // lower and upper vertices of the box of the heightfield\n  lowerVertY : f32,\n  upperVertX : f32,\n  upperVertY : f32,\n  cellDiagX  : f32,  // cell diagonal\n  cellDiagY  : f32,\n}\n\n// Uniforms\n@group(0) @binding(0) var<uniform> simParams : SimulationParams;\n\n@group(1) @binding(1) var inElevation : texture_2d<f32>;\n@group(1) @binding(2) var outElevation : texture_storage_2d<rgba8unorm, write>;\n@group(1) @binding(3) var inUplift : texture_2d<f32>;\n@group(1) @binding(4) var inStream : texture_2d<f32>;\n@group(1) @binding(5) var outStream : texture_storage_2d<rgba8unorm, write>;\n\n// ----------- Global parameters -----------\n// 0: Stream power\n// 1: Stream power + Hillslope (Laplacian)\n// 2: Stream power + Hillslope (Laplacian) + Debris slope\nconst erosionMode : i32 = 2;\n\nconst uplift : f32 = 0.005;//0.01;\nconst k : f32 = 0.05;//0.0005;\nconst k_d : f32 = 10.0;\nconst k_h : f32 = 3.0;//2.0;\nconst p_sa : f32 = 1.0;//0.8;\nconst p_sl : f32 = 1.0;//2.0;\nconst dt : f32 = 7.0;//1.0;\n\n// next 8 neighboring cells\nconst neighbors : array<vec2i, 8> = array<vec2i, 8>(\n  vec2i(0, 1), vec2i(1, 1), \n  vec2i(1, 0), vec2i(1, -1), \n  vec2i(0, -1), vec2i(-1, -1), \n  vec2i(-1, 0), vec2i(-1, 1)\n);\n\n// ----------- Utilities -----------\nfn ToIndex1D(i : i32, j : i32) -> i32 { return i + simParams.nx * j; }\n\nfn ToIndex1DFromCoord(p : vec2i) -> i32 { return p.x + simParams.nx * p.y; }\n\nfn Height(p : vec2i) -> f32 {\n    let color = textureLoad(inElevation, vec2u(p), 0);\n    return color.r;\n}\n\nfn UpliftAt(p : vec2i) -> f32 {\n    let color = textureLoad(inUplift, vec2u(p), 0);\n    return color.r; // also greyscale?\n}\n\nfn StreamAt(p : vec2i) -> f32 {\n    let color = textureLoad(inStream, vec2u(p), 0);\n    return color.r; // also greyscale?\n}\n\nfn ArrayPoint(p : vec2i) -> vec2f {\n  let lowerVert = vec2f(simParams.lowerVertX, simParams.lowerVertY);\n  let cellDiag = vec2f(simParams.cellDiagX, simParams.cellDiagY);\n  return lowerVert + vec2f(p) * cellDiag;\n}\n\nfn Point3D(p : vec2i) -> vec3f {\n  return vec3f(ArrayPoint(p), Height(p));\n}\n\nfn Slope(p : vec2i, q : vec2i) -> f32 {\n  if (p.x < 0 || p.x >= simParams.nx || p.y < 0 || p.y >= simParams.ny) { return 0.0; }\n  if (q.x < 0 || q.x >= simParams.nx || q.y < 0 || q.y >= simParams.ny) { return 0.0; }\n  if (p.x == q.x && p.y == q.y) { return 0.0; }\n\n  var d = length(ArrayPoint(q) - ArrayPoint(p));\n  return (Height(q) - Height(p)) / d;\n}\n\nfn GetFlowSteepest(p : vec2i) -> vec2i {\n  var d = vec2i();\n  var maxSlope = 0.0;\n  for (var i = 0; i < 8; i++) {\n      var ss = Slope(p + neighbors[i], p);\n      if (ss > maxSlope) {\n        maxSlope = ss;\n        d = neighbors[i];\n      }\n  }\n  return d;\n}\n\nfn Stream(p : vec2i) -> f32 {\n  if (p.x < 0 || p.x >= simParams.nx || p.y < 0 || p.y >= simParams.ny) { return 0.0; }\n  \n  return StreamAt(p);\n}\n\nfn WaterSteepest(p : vec2i) -> f32 {\n  var water = 0.0;\n  for (var i = 0; i < 8; i++) {\n      var q = p + neighbors[i];\n      var fd = GetFlowSteepest(q);\n      if ((q + fd).x == p.x && (q + fd).y == p.y) {\n        water += Stream(q);\n      }\n  }\n  return water;\n}\n\nfn Laplacian(p : vec2i) -> f32 {\n  var laplacian = 0.0;\n  var i : i32 = p.x;\n  var j : i32 = p.y;\n\n  var sqrCellDiagX = simParams.cellDiagX * simParams.cellDiagX;\n  var sqrCellDiagY = simParams.cellDiagY * simParams.cellDiagY;\n\n  if (i == 0) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i+1, j)) + Height(vec2i(i+2, j))) / sqrCellDiagX;\n  }\n  else if (i == simParams.nx - 1) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i-1, j)) + Height(vec2i(i-2, j))) / sqrCellDiagX;\n  }\n  else {\n    laplacian += (Height(vec2i(i+1, j)) - 2.0 * Height(vec2i(i, j)) + Height(vec2i(i-1, j))) / sqrCellDiagX;\n  }\n  \n  if (j == 0) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i, j+1)) + Height(vec2i(i, j+2))) / sqrCellDiagY;\n  }\n  else if (i == simParams.nx - 1) {\n    laplacian += (Height(p) - 2.0 * Height(vec2i(i, j-1)) + Height(vec2i(i, j-2))) / sqrCellDiagY;\n  }\n  else {\n    laplacian += (Height(vec2i(i, j+1)) - 2.0 * Height(vec2i(i, j)) + Height(vec2i(i, j-1))) / sqrCellDiagY;\n  }\n\n  return laplacian;\n}\n\nfn Read(p : vec2i) -> vec4f {\n  if (p.x < 0 || p.x >= simParams.nx || p.y < 0 || p.y >= simParams.ny) {\n    return vec4f();\n  }\n\n  var ret = vec4f();\n  ret.x = Height(p);        // Bedrock elevation\n  ret.y = StreamAt(p);      // Stream area\n  ret.z = UpliftAt(p);      // Uplift factor\n  return ret;\n}\n\nfn Write(p : vec2i, data : vec4f) {\n  textureStore(outElevation, p, vec4f(data.x));\n  textureStore(outStream, p, vec4f(data.y));\n}\n\n\n@compute @workgroup_size(64)\nfn main(\n  @builtin(workgroup_id) WorkGroupID : vec3<u32>,\n  @builtin(local_invocation_id) LocalInvocationID : vec3<u32>,\n  @builtin(global_invocation_id) GlobalInvocationID : vec3<u32>\n) {\n  let idX = i32(GlobalInvocationID.x);\n  let idY = i32(GlobalInvocationID.y);\n  if (idX < 0 || idY < 0) { return; }\n  if (idX >= simParams.nx || idY >= simParams.ny) { return; }\n\n  var id : i32 = ToIndex1D(idX, idY);\n  var p : vec2i = vec2i(idX, idY);\n  var data : vec4f = Read(p);\n  var cellDiag = vec2f(simParams.cellDiagX, simParams.cellDiagY);\n\n  // Border nodes are fixed to zero (elevation and drainage)\n  if (p.x == 0 || p.x == simParams.nx - 1 ||\n      p.y == 0 || p.y == simParams.ny - 1) {\n    data.x = 0.0;\n    data.y = 1.0 * length(cellDiag);\n    Write(p, data);\n    return;\n  }\n\n  // Flows accumulation at p\n  var waterIncr = WaterSteepest(p);\n\n  data.y = 1.0 * length(cellDiag);\n  data.y += waterIncr;\n\n  // Erosion at p (relative to steepest)\n  var d = GetFlowSteepest(p);\n  var receiver = Read(p + d);\n  var pSlope = abs(Slope(p + d, p));\n\n  var erosion = k * pow(data.y, p_sa) * pow(pSlope, p_sl);\n\n  var newHeight = data.x;\n  if (erosionMode == 0) {           // Stream power\n    newHeight -= dt * (erosion);\n  }\n  else if (erosionMode == 1) {      // Stream power + Hillslope erosion (Laplacian)\n    newHeight -= dt * (erosion - k_h * Laplacian(p));\n  }\n  else if (erosionMode == 2) {      // Stream power + Hillslope erosion (Laplacian) + Debris flow\n    newHeight -= dt * (erosion - k_h * Laplacian(p) - k_d * pSlope);\n  }\n\n  newHeight = max(newHeight, receiver.x);\n  newHeight += dt * uplift * data.z;\n\n  data.x = newHeight;\n  Write(p, data);\n}"}),entryPoint:"main"}}),G=u.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),S=u.createBindGroup({label:"simulation constants",layout:E.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:G}}]}),D=u.createBindGroup({label:"compute bind group 0",layout:E.getBindGroupLayout(1),entries:[{binding:1,resource:_[0].createView()},{binding:2,resource:_[1].createView()},{binding:3,resource:U.createView()},{binding:4,resource:T[0].createView()},{binding:5,resource:T[1].createView()}]}),R=u.createBindGroup({label:"compute bind group 1",layout:E.getBindGroupLayout(1),entries:[{binding:1,resource:_[1].createView()},{binding:2,resource:_[0].createView()},{binding:3,resource:U.createView()},{binding:4,resource:T[1].createView()},{binding:5,resource:T[0].createView()}]}),V=[D,R];n.createBindGroup(g,w,0,x,_[v]),i.createBindGroup(g,w,256,x,_[v]);let M={nx:256,ny:256,lowerVertX:-15e4,lowerVertY:-15e4,upperVertX:15e4,upperVertY:15e4,cellDiagX:1176.47,cellDiagY:1176.47};u.queue.writeBuffer(G,0,new Float32Array([M.nx,M.ny,M.lowerVertX,M.lowerVertY,M.upperVertX,M.upperVertY,M.cellDiagX,M.cellDiagY])),requestAnimationFrame(function frame(){if(!r.active)return;a._E.identity(f.viewMatrix),a._E.translate(f.viewMatrix,f.target,f.viewMatrix),a._E.rotateX(f.viewMatrix,-.2*Math.PI,f.viewMatrix),f.update();let e=u.createCommandEncoder();{let t=e.beginComputePass();t.setPipeline(E),t.setBindGroup(0,S),t.setBindGroup(1,V[v]),t.dispatchWorkgroups(Math.ceil(b),Math.ceil(P)),t.end(),v=(v+1)%2}{let t=e.beginRenderPass({colorAttachments:[{view:l.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});t.setPipeline(g),writeMVPUniformBuffer(u,w,0,n.getModelMatrix(),f.viewMatrix,f.projectionMatrix),t.setBindGroup(0,n.bindGroup),t.setIndexBuffer(n.indexBuffer,"uint32"),t.setVertexBuffer(0,n.posBuffer),t.setVertexBuffer(1,n.normalBuffer),t.setVertexBuffer(2,n.uvBuffer),t.drawIndexed(n.count),writeMVPUniformBuffer(u,w,256,i.getModelMatrix(),a._E.identity(),a._E.identity()),t.setBindGroup(0,i.bindGroup),t.setIndexBuffer(i.indexBuffer,"uint32"),t.setVertexBuffer(0,i.posBuffer),t.setVertexBuffer(1,i.normalBuffer),t.setVertexBuffer(2,i.uvBuffer),t.drawIndexed(i.count),t.end()}u.queue.submit([e.finish()]),requestAnimationFrame(frame)})};var pages=()=>makeSample({name:"Terrain X",description:"Interactive terrain authoring and erosion simulation on WebGPU",gui:!0,stats:!0,init,filename:"src/sample/terrainX/main.ts"})},4131:function(e){e.exports={canvasContainer:"SampleLayout_canvasContainer__ZTWP5"}}},function(e){e.O(0,[746,150,774,888,179],function(){return e(e.s=8312)}),_N_E=e.O()}]);